\chapter{Fazit}
\label{cha:k7}

%%%%%%%%%%%%%%%%%%AUTO ODER MANUAL%%%%%%%%%%%%%%%%%%%%

As mentioned earlier, sometimes it is not possible to cover the ins and outs of the target system or perform fuzzing manually using large number of payloads. In such cases, we can use an automated tool to do our job. It saves a lot of manual effort and time.
Automated tools can also be used for information gathering techniques, which can be very useful before starting the discovery phase. Hence, in such cases, we can use an automated tool to find the right target after which we can use manual assessment to exploit the vulnerability. Even in cases where the size of the application is large, an automated security scan comes handy. However, the result given by the automated tool isn’t necessarily the conclusion. A manual analysis is often required to confirm the vulnerabilities. Manual techniques are also helpful in finding business logic flaws. Thus, a mix of both automated and manual testing would be the best fit to save time and get the best output.



Automated penetration testing tools tend to be more efficient and thorough, and chances are that malicious hackers are going to use automated attacks against you. These automated test tools come from many sources, including commercial, open-source and custom designed. Often these tools focus on a particular vulnerability area, so multiple penetration testing tools may be needed. Because these automated tools are updated monthly or weekly, you must manually verify the output from the automated tools to check for false alarms and to test for the latest vulnerabilities. With over 50 new vulnerabilities being discovered each week, there will always be new vulnerabilities that the tools may not be able to detect. Without doing this manual testing, your penetration testing will be incomplete. 

Zusammenfassend soll nicht in die Debatte zwischen manuellen und automatisierten Tests verwickelt werden. Beide dienen ihren individuellen Zwecken wunderbar. Es soll das optimale Gleichgewicht bei dem Testen von jede Anwendung gefunden werden.

%%%%%%%%%%%%%%%%%%%%%%%%%REST API%%%%%%%%%%%%%%%%%%%%%%%%

API testing is a vast area of research and is still evolving. In this chapter, we saw a
generic methodology that one should apply to test any kind of API. This included
studying the API structure, understanding request methods, understanding
responses, and so on. It also included techniques which one should apply to list
endpoints and exploit bugs on real production API. We saw examples of API bugs
on sites, such as Facebook, in which we applied our generic methodology to study
(learn) about API by understanding structure, roles, scopes, etc. and then exploiting
it. API testing has still not evolved, and there's a lot of scope in research.
For learning more about how real API bugs are exploited, I would recommend
readers read the following:
http://philippeharewood.com/
https://pranavhivarekar.in/
APIs have gained a lot of popularity nowadays and have brought immense flexibility
to cross application integrations, but they also give rise to large and complex attack
surfaces. Due to this attack surface factor, APIs must be tested rigorously for logical
and implementation-related vulnerabilities, which are often very critical in nature,
such as account takeover flaws.


Although software teams acknowledge the desire to reach an ideal distribution of unit, API, and UI tests, the reality is that your average team is doing an average job of unit testing and still relying on late-stage UI and system tests. API testing provides an ideal communication mechanism between developers and testers with a high level of maintainable automation that can be extended into performance and security testing.

Shifting these tests left and executing them earlier in the software lifecycle means catching critical security and architectural defects early, where they are easier to diagnose and less risky to fix. Leveraging the automation provided by Parasoft SOAtest's Smart API Test Generator, API testing is more accessible and the time associated with creating meaningful test scenarios can be significantly reduced.



Manual security testing of web service APIs is an expensive and time-intensive, though
necessary and important part of serious software development. Despite security being of
utmost importance, it might be neglected for various reasons. Even when security is a
priority for developers, it is possible that there exist one or more security vulnerabilities
in a system. Automating parts of the security testing process allows software development
teams to integrate automated security testing as a part of their automated testing process,
reducing the chance of introducing testable security related software vulnerabilities in concurrent software builds.



%%%%%%%%%%%%%%%%%%SWAGGER VS OPENAPI%%%%%%%%%%%%%%%%%%%%

Swagger 2.0 ist aufgrund der hohen Verbreitung und der umfangreichen Toolunterstützung der Quasistandard für die Schnittstellenbeschreibung REST-basierter Anwendungen. Die OpenAPI Specification 3.0.0 sorgt für Ordnung in der gewachsenen Swagger-Struktur. Durch ein breites Gremium, in dem alle namhaften Hersteller vertreten sind, und die neuen Features, wird sich die OpenAPI Specification in der Branche durchsetzen und Swagger 2.0 ablösen, sobald die Toolunterstützung auf die neue Version angepasst ist.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%