\chapter{Fazit}
\label{cha:k7}

%%%%%%%%%%%%%%%%%%AUTO ODER MANUAL%%%%%%%%%%%%%%%%%%%%

Wie bereits in Kapitel  \ref{cha:k4} erwähnt, ist es manchmal nicht möglich, alle Testfälle manuell zu überlegen, um die Penetrationstests des Zielsystems abzudecken. In solchen Fällen kann ein automatisiertes Werkzeug verwendet werden, um die Penetrationstests zu erledigen und dabei manuellen Aufwand und Zeit zu sparen. Automatisierte Tools können auch für das Sammeln von Informationen verwendet werden, was vor Beginn der Ermittlungsphase hilfreich sein kann. Daher kann in solchen Fällen ein automatisiertes Tool genutzt werden, um das richtige Ziel zu finden, nach dem die manuelle Schwachstelle ausgenutzt werden kann. Selbst bei umfangreichen Anwendungen ist ein automatisierter Penetrationstest sinnvoll. Das Ergebnis des automatisierten Tools ist jedoch nicht unbedingt die Schlussfolgerung. Zur Bestätigung der Schwachstellen ist häufig eine manuelle Analyse erforderlich. Manuelle Techniken sind auch hilfreich beim Auffinden von Geschäftslogikfehlern (Business Logic Flaws).

Automatisierte Penetrationstest-Tools sind in der Regel effizienter und gründlicher, aber es besteht die Gefahr, dass böswillige Hacker automatisierte Angriffe gegen unsere Systeme durchführen. Diese automatisierten Testwerkzeuge stammen aus diversen Quellen wie kommerziellen oder Open-Source-Quellen. Häufig konzentrieren sich diese Tools auf einen bestimmten Schwachstellenbereich, sodass möglicherweise mehrere Penetrationstest-Tools erforderlich sind. Da diese automatisierten Tools monatlich oder wöchentlich aktualisiert werden, muss die Ausgabe der automatisierten Tools manuell überprüft werden, um nach Fehlalarmen zu suchen und auf die neuesten Sicherheitsanfälligkeiten zu testen. Jeden Tag werden mehrere neue Schwachstellen entdeckt, die von automatisierten Tools eventuell nicht erkannt werden können.

Zusammenfassend sind sowohl manuelle als auch automatisierte Tests entsprechend ihren individuellen Zwecken effektiv. Es sollte das optimale Gleichgewicht beim Testen jeder Anwendung gefunden werden.\\

%%%%%%%%%%%%%%%%%%%%%%%%%REST API%%%%%%%%%%%%%%%%%%%%%%%%

APIs haben heute eine große Popularität und eine immense Flexibilität für anwendungsübergreifende Integrationen. Sie verursachen jedoch auch große und komplexe Angriffsflächen. Aufgrund dieses Angriffsoberflächenfaktors müssen APIs strikt auf logische und implementierungsabhängige Schwachstellen getestet werden, die häufig kritisch sind, z. B. Fehler bei der Kontoübernahme.

API-Tests sind ein weites Forschungsgebiet und entwickeln sich noch weiter. In Kapitel \ref{cha:k5} wurde eine automatisierte Penetrationstest-Methodik vorgestellt, die man anwenden sollte, um jede Art von API zu testen. Dazu gehörten der Swagger-Generator, das Verstehen von Spider, Active Scan usw. Es wurden darüber hinaus Techniken präsentiert, die zum Auflisten von Endpunkten und zum Ausnutzen von Fehlern in der realen Produktions-API angewendet werden sollten. Auch wurden Beispiele für API-Fehler auf das Framework wie Spring Boot gezeigt, in dem unsere generische Testmethodik angewendet wurde, um API auszunutzen. API-Tests haben sich immer noch nicht weiterentwickelt und es sind Lücken in der Forschung zu schließen.

API-Tests bieten einen idealen Kommunikationsmechanismus zwischen Entwicklern und Testern mit einem hohen Grad an wartungsfähiger Automatisierung, der zu Leistungs- und Sicherheitstests erweitert werden kann. Wenn die API-Tests zu einem früheren Zeitpunkt im Software-Lebenszyklus ausgeführt werden, bedeutet dies, dass die kritische Sicherheits- und Architekturdefekte frühzeitig erkannt und leichter diagnostiziert werden. Zudem ist es weniger riskant, solche Sicherheitsanfälligkeiten zu beheben. Durch die Nutzung der von OWASP ZAP bereitgestellten und vom OpenAPI 2.0 Plugin durchgeführten Automatisierung, ist der API-Test einfacher zugänglich und die Zeit, die zum Erstellen aussagekräftiger Testszenarien erforderlich ist, kann erheblich reduziert werden.

Das manuelle Testen der Sicherheit von Web-Service-APIs ist ein kostspieliger und zeitintensiver, wenngleich notwendiger Bestandteil einer ernsthaften Softwareentwicklung. Obwohl Sicherheit von größter Bedeutung ist, wird sie aus verschiedenen Gründen vernachlässigt. Selbst wenn Sicherheit für Entwickler eine Priorität darstellt, gibt es möglicherweise eine oder mehrere Sicherheitslücken in einem System. Durch die Automatisierung von Teilen des Sicherheitstestprozesses können Softwareentwicklungsteams automatisierte Sicherheitstests als Teil ihres automatisierten Testprozesses integrieren. Dadurch wird die Wahrscheinlichkeit verringert, dass testbare, sicherheitsrelevante Softwareanfälligkeiten in gleichzeitigen Software-Builds auftreten.\\

%%%%%%%%%%%%%%%%%% SWAGGER VS OPENAPI %%%%%%%%%%%%%%%%%%%%

Im Kapitel \ref{cha:k6} wurden die wichtigsten Änderungen an der OpenAPI Spec 3.0 erörtert. Dies stellt hinsichtlich der REST-API-Definitionen einen großen Fortschritt dar. Ich glaube, mit der Unterstützung visueller API-Editor-Tools wie Swagger oder des automatisierten REST-Dokumente-Generators für das Framework Spring Boot, wenn diese Tools auch OAS 3.0 unterstützen, wird die Verwendung der neuen Spezifikationen auch für Nichtentwickler mit wenigen technischen Kenntnissen erleichtert.

Heute sind OpenAPI Spezifikationen der klare Marktführer bei den API-Definitionsformaten, wobei die größte Akzeptanz sowie die Anzahl der entwickelten Werkzeuge vorhanden ist. Während Dokumentation immer noch der wichtigste Grund für das Erstellen von API-Definitionen sind, gibt es zahlreiche andere Gründe für die Verwendung von API-Definitionen, z. B. Mocking, Testen oder Überwachen. Es ist klar, dass die Version 3.0 der Spezifikation die Entwurfsmuster über eine große Anzahl von Implementierungen hinweg berücksichtigt hat und eine weitreichende Spezifikation für die Definition der Funktion einer API bereitstellt. Die Verbesserung der von der Spezifikation angebotenen Objekte ist bei der Vereinfachung der Erstellung von Definitionen, die in einer API-Spezifikation wiederverwendet werden können, wertvoll.

Hinsichtlich der Schnittstellenbeschreibung REST-basierter Anwendungen ist OpenAPI 2.0, wohl aufgrund der umfangreichen Toolunterstützung und weiten Verbreitung, die beste Option. In der gewachsenen Swagger-Struktur bietet die OpenAPI Specification 3.0 ein gewisses Maß an Ordnung. Sobald die Toolunterstützung an die neue Version adaptiert ist, wird sich die OpenAPI Specification branchenweit durchsetzen und somit an die Stelle von Swagger 2.0 treten – vor allem durch ein Gremium mit namhaften Herstellern sowie durch alle neuen Features.

Wie bereits erwähnt, sind OpenAPI 2.0 und 3.0 nicht kompatibel. Dies bedeutet, dass für beide Tools, die sich mit OpenAPI beschäftigen, ein Update notwendig ist, um das neue Format zu unterstützen. Das OpenAPI bietet eine umfangreiche Liste mit Tools mit der Version 3.0 Support. Falls die bevorzugten Tools jedoch Version 3.0 nicht unterstützen, ist es möglich, mit Version 2.0 fortzufahren, solange man keine Features der neuen Version 3.0 benötigt.

Wie bereits erwähnt sind OpenAPI 2.0 und 3.0 nicht kompatibel. Dies bedeutet, dass für beide Tools, die sich mit OpenAPI beschäftigen, ein Update notwendig ist, um das neue Format zu unterstützen. Das OpenAPI bietet eine endlose Liste mit Tools an, die nicht von der Version 3.0 unterstützt werden. Da die bevorzugten Tools jedoch Version 3.0 nicht unterstützen, ist es empfehlenswert mit Version 2.0 fortzufahren, solange man keine der neuen Version 3.0 Features benötigt.

Aus diesem Grund wäre es hierbei sinnvoll das bereits bestehende OpenAPI Plugin für OWASP Zap um die Unterstützung für OpenAPI 3.0 zu erweitern. Dadurch könnte das Plugin wahlweise OpenAPI 2.0 oder OpenAPI 3.0 einlesen. Gegebenenfalls wäre es sogar wirksam auch RAML-Support noch zusätzlich einzubauen, um eine gewissen Flexibilität zu gewährleisten.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





