\chapter{Fazit}
\label{cha:k7}

%%%%%%%%%%%%%%%%%%AUTO ODER MANUAL%%%%%%%%%%%%%%%%%%%%

Wie bereits in dem Kapitel \ref{cha:k4} erwähnt, ist es manchmal nicht möglich, alle Testfällen manuell zu überlegen, um die Penetrationstests des Zielsystems abzudecken. In solchen Fällen können ein automatisiertes Werkzeug verwendet werden, um die Penetrationstests zu erledigen, indem viel manuellen Aufwand und Zeit gespart wird. Automatisierte Tools können auch für das Sammeln von Informationen verwendet werden, was vor Beginn der Ermittlungsphase sehr nützlich sein kann. Daher kann in solchen Fällen ein automatisiertes Tool verwendet werden, um das richtige Ziel zu finden, nach dem die manuelle Schwachstelle ausgenutzt werden kann. Selbst in Fällen, in denen die Größe der Anwendung groß ist, ist ein automatisierte Penetrationstests sinnvoll. Das Ergebnis des automatisierten Tools ist jedoch nicht unbedingt die Schlussfolgerung. Zur Bestätigung der Schwachstellen ist häufig eine manuelle Analyse erforderlich. Manuelle Techniken sind auch hilfreich beim Auffinden von Geschäftslogikfehlern (engl. Business logic flaws).

Automatisierte Penetrationstest-Tools sind in der Regel effizienter und gründlicher, aber es besteht die Gefahr, dass böswillige Hacker automatisierte Angriffe gegen unseren Systeme durchführen. Diese automatisierten Testwerkzeuge stammen aus vielen Quellen wie z.B. kommerziell oder Open-Source. Häufig konzentrieren sich diese Tools auf einen bestimmten Schwachstellenbereich, so dass möglicherweise mehrere Penetrationstest-Tools erforderlich sind. Da diese automatisierten Tools monatlich oder wöchentlich aktualisiert werden, müssen Sie die Ausgabe der automatisierten Tools manuell überprüfen, um nach Fehlalarmen zu suchen und auf die neuesten Sicherheitsanfälligkeiten zu prüfen. Jeden Tag werden mehrere neue Schwachstellen entdeckt, die von automatisierter Tools möglicherweise nicht erkannt werden können.

Zusammenfassend soll nicht in die Debatte zwischen manuellen und automatisierten Tests verwickelt werden, weil beide Methode ihren individuellen Zwecken sehr gut dienen. Es soll das optimale Gleichgewicht bei dem Testen von jede Anwendung gefunden werden.\\

%%%%%%%%%%%%%%%%%%%%%%%%%REST API%%%%%%%%%%%%%%%%%%%%%%%%

API testing is a vast area of research and is still evolving. In this chapter, we saw a
generic methodology that one should apply to test any kind of API. This included
studying the API structure, understanding request methods, understanding
responses, and so on. It also included techniques which one should apply to list
endpoints and exploit bugs on real production API. We saw examples of API bugs
on sites, such as Facebook, in which we applied our generic methodology to study
(learn) about API by understanding structure, roles, scopes, etc. and then exploiting
it. API testing has still not evolved, and there's a lot of scope in research.
For learning more about how real API bugs are exploited, I would recommend
readers read the following:
http://philippeharewood.com/
https://pranavhivarekar.in/
APIs have gained a lot of popularity nowadays and have brought immense flexibility
to cross application integrations, but they also give rise to large and complex attack
surfaces. Due to this attack surface factor, APIs must be tested rigorously for logical
and implementation-related vulnerabilities, which are often very critical in nature,
such as account takeover flaws.


Although software teams acknowledge the desire to reach an ideal distribution of unit, API, and UI tests, the reality is that your average team is doing an average job of unit testing and still relying on late-stage UI and system tests. API testing provides an ideal communication mechanism between developers and testers with a high level of maintainable automation that can be extended into performance and security testing.

Shifting these tests left and executing them earlier in the software lifecycle means catching critical security and architectural defects early, where they are easier to diagnose and less risky to fix. Leveraging the automation provided by Parasoft SOAtest's Smart API Test Generator, API testing is more accessible and the time associated with creating meaningful test scenarios can be significantly reduced.



Manual security testing of web service APIs is an expensive and time-intensive, though
necessary and important part of serious software development. Despite security being of
utmost importance, it might be neglected for various reasons. Even when security is a
priority for developers, it is possible that there exist one or more security vulnerabilities
in a system. Automating parts of the security testing process allows software development
teams to integrate automated security testing as a part of their automated testing process,
reducing the chance of introducing testable security related software vulnerabilities in concurrent software builds.



%%%%%%%%%%%%%%%%%% SWAGGER VS OPENAPI %%%%%%%%%%%%%%%%%%%%

Swagger 2.0 ist aufgrund der hohen Verbreitung und der umfangreichen Toolunterstützung der Quasistandard für die Schnittstellenbeschreibung REST-basierter Anwendungen. Die OpenAPI Specification 3.0.0 sorgt für Ordnung in der gewachsenen Swagger-Struktur. Durch ein breites Gremium, in dem alle namhaften Hersteller vertreten sind, und die neuen Features, wird sich die OpenAPI Specification in der Branche durchsetzen und Swagger 2.0 ablösen, sobald die Toolunterstützung auf die neue Version angepasst ist.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





