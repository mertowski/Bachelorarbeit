\chapter{Fazit}
\label{cha:k7}

%%%%%%%%%%%%%%%%%%AUTO ODER MANUAL%%%%%%%%%%%%%%%%%%%%

Wie bereits in dem Kapitel \ref{cha:k4} erwähnt, ist es manchmal nicht möglich, alle Testfällen manuell zu überlegen, um die Penetrationstests des Zielsystems abzudecken. In solchen Fällen können ein automatisiertes Werkzeug verwendet werden, um die Penetrationstests zu erledigen, indem viel manuellen Aufwand und Zeit gespart wird. Automatisierte Tools können auch für das Sammeln von Informationen verwendet werden, was vor Beginn der Ermittlungsphase sehr nützlich sein kann. Daher kann in solchen Fällen ein automatisiertes Tool verwendet werden, um das richtige Ziel zu finden, nach dem die manuelle Schwachstelle ausgenutzt werden kann. Selbst in Fällen, in denen die Größe der Anwendung groß ist, ist ein automatisierte Penetrationstests sinnvoll. Das Ergebnis des automatisierten Tools ist jedoch nicht unbedingt die Schlussfolgerung. Zur Bestätigung der Schwachstellen ist häufig eine manuelle Analyse erforderlich. Manuelle Techniken sind auch hilfreich beim Auffinden von Geschäftslogikfehlern (engl. Business logic flaws).

Automatisierte Penetrationstest-Tools sind in der Regel effizienter und gründlicher, aber es besteht die Gefahr, dass böswillige Hacker automatisierte Angriffe gegen unseren Systeme durchführen. Diese automatisierten Testwerkzeuge stammen aus vielen Quellen wie z.B. kommerziell oder Open-Source. Häufig konzentrieren sich diese Tools auf einen bestimmten Schwachstellenbereich, so dass möglicherweise mehrere Penetrationstest-Tools erforderlich sind. Da diese automatisierten Tools monatlich oder wöchentlich aktualisiert werden, müssen Sie die Ausgabe der automatisierten Tools manuell überprüfen, um nach Fehlalarmen zu suchen und auf die neuesten Sicherheitsanfälligkeiten zu prüfen. Jeden Tag werden mehrere neue Schwachstellen entdeckt, die von automatisierter Tools möglicherweise nicht erkannt werden können.

Zusammenfassend soll nicht in die Debatte zwischen manuellen und automatisierten Tests verwickelt werden, weil beide Methode ihren individuellen Zwecken sehr gut dienen. Es soll das optimale Gleichgewicht bei dem Testen von jede Anwendung gefunden werden.\\

%%%%%%%%%%%%%%%%%%%%%%%%%REST API%%%%%%%%%%%%%%%%%%%%%%%%

APIs haben heutzutage eine große Popularität erlangt und eine immense Flexibilität für anwendungsübergreifende Integrationen mit sich gebracht, sie verursachen jedoch auch große und komplexe Angriffsflächen. Aufgrund dieses Angriffsoberflächenfaktors müssen APIs strikt auf logische und implementierungsabhängige Schwachstellen getestet werden, die häufig sehr kritisch sind, z. B. Fehler bei der Kontoübernahme.

API-Tests sind ein weites Forschungsgebiet und entwickeln sie sich noch weiter. In Kapitel \ref{cha:k5} haben wir eine automatisierte Penetrationstest-Methodik gesehen, die man anwenden sollte, um jede Art von API zu testen. Dazu gehörten die Swagger-Generator, das Verstehen von Spider, das Verstehen von Active Scan usw. Es enthielt auch Techniken, die zum Auflisten von Endpunkten und zum Ausnutzen von Fehlern in der realen Produktions-API angewendet werden sollten. Wir haben Beispiele für API-Fehler auf das Framework wie Springboot gesehen, in dem wir unsere generische Testmethodik angewendet haben, um API auszunutzen. API-Tests haben sich immer noch nicht weiterentwickelt, und es gibt viel Spielraum in der Forschung.

API-Tests bieten einen idealen Kommunikationsmechanismus zwischen Entwicklern und Testern mit einem hohen Grad an wartungsfähiger Automatisierung, der zu Leistungs- und Sicherheitstests erweitert werden kann. Wenn die API-Tests zu einem früheren Zeitpunkt im Software-Lebenszyklus ausgeführt werden, bedeutet dies, dass die kritische Sicherheits- und Architekturdefekte frühzeitig erkannt und leichter diagnostizieren werden und es ist weniger riskant solche Sicherheitsanfälligkeiten beheben können. Durch die Nutzung des OpenAPI 2.0 Plug-Ins von OWASP ZAP bereitgestellten Automatisierung ist der API-Test einfacher zugänglich, und die Zeit, die zum Erstellen aussagekräftiger Testszenarien erforderlich ist, kann erheblich reduziert werden.

Das manuelle Testen der Sicherheit von Web-Service-APIs ist ein kostspieliger und zeitintensiver, wenngleich notwendiger und wichtiger Bestandteil einer ernsthaften Softwareentwicklung. Obwohl Sicherheit von größter Bedeutung ist, kann sie aus verschiedenen Gründen vernachlässigt werden. Selbst wenn Sicherheit für Entwickler eine Priorität darstellt, gibt es möglicherweise eine oder mehrere Sicherheitslücken in einem System. Durch die Automatisierung von Teilen des Sicherheitstestprozesses können Softwareentwicklungsteams automatisierte Sicherheitstests als Teil ihres automatisierten Testprozesses integrieren, wodurch die Wahrscheinlichkeit, dass testbare, sicherheitsrelevante Softwareanfälligkeiten in gleichzeitigen Software-Builds auftreten, verringert wird.\\

%%%%%%%%%%%%%%%%%% SWAGGER VS OPENAPI %%%%%%%%%%%%%%%%%%%%

Im Kapitel \ref{cha:k6} wurde zumindest aus meiner Sicht die wichtigsten Änderungen an der OpenAPI Spec 3.0 erörtert. Ich bin der Meinung, dass dies hinsichtlich der REST-API-Definitionen ein großer Schritt nach vorne ist. Ich glaube, mit der Unterstützung visueller API-Editor-Tools wie ApiBldr oder ein automatisierte REST-Dokumente-Generator für das Framework Springboot, wenn diese Tools auch OAS 3.0 unterstützt, wird es die Verwendung der neuen Spezifikationen auch für Nicht-Entwickler mit wenig technischen Kenntnissen erleichtern.

Heute ist OpenAPI Spezifikationen der klare Marktführer bei den API Definitionsformaten, wobei die größte Akzeptanz sowie die Anzahl der entwickelten Werkzeuge vorhanden ist. Während Dokumentation immer noch der wichtigsten Grund für das Erstellen von API-Definitionen sind, gibt es zahlreiche andere Gründe für die Verwendung von API-Definitionen, einschließlich Mocking, Testen, Überwachen und vieles mehr. Es ist klar, dass die Version 3.0 der Spezifikation die Entwurfsmuster über eine große Anzahl von Implementierungen hinweg berücksichtigt hat und eine ziemlich weitreichende Spezifikation für die Definition der Funktion einer API bereitstellt. Die Verbesserung der von der Spezifikation angebotenen Objekte ist bei der Vereinfachung der Erstellung von Definitionen, die in einer API-Spezifikation wiederverwendet werden können, überaus wertvoll.

Wenn es um Schnittstellenbeschreibung REST-basierter Anwendungen geht, ist OpenAPI 2.0, wohl aufgrund der umfangreichen Toolunterstützung und weiten Verbreitung, die beste Option. In der gewachsenen Swagger-Struktur bietet die OpenAPI Specification 3.0 ein gewisses Maß an Ordnung. Sobald die Toolunterstützung an die neue Version adaptiert ist, wird sich die OpenAPI Specification branchenweit durchsetzen und somit an die Stelle von Swagger 2.0 treten – vor allem durch ein mit allen namhaften Herstellern gespicktes Gremium und allen neuen Features der OpenAPI Specification.

Wie bereits erwähnt sind OpenAPI 2.0 und 3.0 nicht kompatibel. Dies bedeutet, dass für beide Tools, die sich mit OpenAPI beschäftigen, ein Update notwendig ist, um das neue Format zu unterstützen. Das OpenAPI bietet eine endlose Liste mit Tools mit der Version 3.0 Support. Falls die bevorzugten Tools jedoch Version 3.0 nicht unterstützen, ist es möglich mit Version 2.0 fortzufahren, solange man keine der neuen Version 3.0 Features benötigt.

Aus diesem Grund sollte anstatt der Entwicklung eines neuen OpenAPI 3.0 Plugins, vorerst die Möglichkeit einer Implementierung des OpenAPI 2.0 Plugins in das OpenAPI 3.0 Plugin vorangetrieben werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





